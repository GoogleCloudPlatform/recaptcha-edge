// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "recaptchaenterprise.proto" (package "google.cloud.recaptchaenterprise.v1", syntax proto3)
// tslint:disable
//
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type {
  BinaryReadOptions,
  BinaryWriteOptions,
  IBinaryReader,
  IBinaryWriter,
  PartialMessage,
} from '@protobuf-ts/runtime';
import {
  MessageType,
  reflectionMergePartial,
  UnknownFieldHandler,
  WireType,
} from '@protobuf-ts/runtime';
import {FieldMask} from './google/protobuf/field_mask';
import {Timestamp} from './google/protobuf/timestamp';
import {Status} from './status';
/**
 * The create assessment request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.CreateAssessmentRequest
 */
export interface CreateAssessmentRequest {
  /**
   * Required. The name of the project in which the assessment will be created,
   * in the format `projects/{project}`.
   *
   * @generated from protobuf field: string parent = 1;
   */
  parent: string;
  /**
   * Required. The assessment details.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.Assessment assessment = 2;
   */
  assessment?: Assessment;
}
/**
 * Describes an event in the lifecycle of a payment transaction.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.TransactionEvent
 */
export interface TransactionEvent {
  /**
   * Optional. The type of this transaction event.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TransactionEvent.TransactionEventType event_type = 1;
   */
  eventType: TransactionEvent_TransactionEventType;
  /**
   * Optional. The reason or standardized code that corresponds with this
   * transaction event, if one exists. For example, a CHARGEBACK event with code
   * 6005.
   *
   * @generated from protobuf field: string reason = 2;
   */
  reason: string;
  /**
   * Optional. The value that corresponds with this transaction event, if one
   * exists. For example, a refund event where $5.00 was refunded. Currency is
   * obtained from the original transaction data.
   *
   * @generated from protobuf field: double value = 3;
   */
  value: number;
  /**
   * Optional. Timestamp when this transaction event occurred; otherwise assumed
   * to be the time of the API call.
   *
   * @generated from protobuf field: google.protobuf.Timestamp event_time = 4;
   */
  eventTime?: Timestamp;
}
/**
 * Enum that represents an event in the payment transaction lifecycle.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.TransactionEvent.TransactionEventType
 */
export enum TransactionEvent_TransactionEventType {
  /**
   * Default, unspecified event type.
   *
   * @generated from protobuf enum value: TRANSACTION_EVENT_TYPE_UNSPECIFIED = 0;
   */
  TRANSACTION_EVENT_TYPE_UNSPECIFIED = 0,
  /**
   * Indicates that the transaction is approved by the merchant. The
   * accompanying reasons can include terms such as 'INHOUSE', 'ACCERTIFY',
   * 'CYBERSOURCE', or 'MANUAL_REVIEW'.
   *
   * @generated from protobuf enum value: MERCHANT_APPROVE = 1;
   */
  MERCHANT_APPROVE = 1,
  /**
   * Indicates that the transaction is denied and concluded due to risks
   * detected by the merchant. The accompanying reasons can include terms such
   * as 'INHOUSE',  'ACCERTIFY',  'CYBERSOURCE', or 'MANUAL_REVIEW'.
   *
   * @generated from protobuf enum value: MERCHANT_DENY = 2;
   */
  MERCHANT_DENY = 2,
  /**
   * Indicates that the transaction is being evaluated by a human, due to
   * suspicion or risk.
   *
   * @generated from protobuf enum value: MANUAL_REVIEW = 3;
   */
  MANUAL_REVIEW = 3,
  /**
   * Indicates that the authorization attempt with the card issuer succeeded.
   *
   * @generated from protobuf enum value: AUTHORIZATION = 4;
   */
  AUTHORIZATION = 4,
  /**
   * Indicates that the authorization attempt with the card issuer failed.
   * The accompanying reasons can include Visa's '54' indicating that the card
   * is expired, or '82' indicating that the CVV is incorrect.
   *
   * @generated from protobuf enum value: AUTHORIZATION_DECLINE = 5;
   */
  AUTHORIZATION_DECLINE = 5,
  /**
   * Indicates that the transaction is completed because the funds were
   * settled.
   *
   * @generated from protobuf enum value: PAYMENT_CAPTURE = 6;
   */
  PAYMENT_CAPTURE = 6,
  /**
   * Indicates that the transaction could not be completed because the funds
   * were not settled.
   *
   * @generated from protobuf enum value: PAYMENT_CAPTURE_DECLINE = 7;
   */
  PAYMENT_CAPTURE_DECLINE = 7,
  /**
   * Indicates that the transaction has been canceled. Specify the reason
   * for the cancellation. For example, 'INSUFFICIENT_INVENTORY'.
   *
   * @generated from protobuf enum value: CANCEL = 8;
   */
  CANCEL = 8,
  /**
   * Indicates that the merchant has received a chargeback inquiry due to
   * fraud for the transaction, requesting additional information before a
   * fraud chargeback is officially issued and a formal chargeback
   * notification is sent.
   *
   * @generated from protobuf enum value: CHARGEBACK_INQUIRY = 9;
   */
  CHARGEBACK_INQUIRY = 9,
  /**
   * Indicates that the merchant has received a chargeback alert due to fraud
   * for the transaction. The process of resolving the dispute without
   * involving the payment network is started.
   *
   * @generated from protobuf enum value: CHARGEBACK_ALERT = 10;
   */
  CHARGEBACK_ALERT = 10,
  /**
   * Indicates that a fraud notification is issued for the transaction, sent
   * by the payment instrument's issuing bank because the transaction appears
   * to be fraudulent. We recommend including TC40 or SAFE data in the
   * `reason` field for this event type. For partial chargebacks, we recommend
   * that you include an amount in the `value` field.
   *
   * @generated from protobuf enum value: FRAUD_NOTIFICATION = 11;
   */
  FRAUD_NOTIFICATION = 11,
  /**
   * Indicates that the merchant is informed by the payment network that the
   * transaction has entered the chargeback process due to fraud. Reason code
   * examples include Discover's '6005' and '6041'. For partial chargebacks,
   * we recommend that you include an amount in the `value` field.
   *
   * @generated from protobuf enum value: CHARGEBACK = 12;
   */
  CHARGEBACK = 12,
  /**
   * Indicates that the transaction has entered the chargeback process due to
   * fraud, and that the merchant has chosen to enter representment. Reason
   * examples include Discover's '6005' and '6041'. For partial chargebacks,
   * we recommend that you include an amount in the `value` field.
   *
   * @generated from protobuf enum value: CHARGEBACK_REPRESENTMENT = 13;
   */
  CHARGEBACK_REPRESENTMENT = 13,
  /**
   * Indicates that the transaction has had a fraud chargeback which was
   * illegitimate and was reversed as a result. For partial chargebacks, we
   * recommend that you include an amount in the `value` field.
   *
   * @generated from protobuf enum value: CHARGEBACK_REVERSE = 14;
   */
  CHARGEBACK_REVERSE = 14,
  /**
   * Indicates that the merchant has received a refund for a completed
   * transaction. For partial refunds, we recommend that you include an amount
   * in the `value` field. Reason example: 'TAX_EXEMPT' (partial refund of
   * exempt tax)
   *
   * @generated from protobuf enum value: REFUND_REQUEST = 15;
   */
  REFUND_REQUEST = 15,
  /**
   * Indicates that the merchant has received a refund request for this
   * transaction, but that they have declined it. For partial refunds, we
   * recommend that you include an amount in the `value` field. Reason
   * example: 'TAX_EXEMPT' (partial refund of exempt tax)
   *
   * @generated from protobuf enum value: REFUND_DECLINE = 16;
   */
  REFUND_DECLINE = 16,
  /**
   * Indicates that the completed transaction was refunded by the merchant.
   * For partial refunds, we recommend that you include an amount in the
   * `value` field. Reason example: 'TAX_EXEMPT' (partial refund of exempt
   * tax)
   *
   * @generated from protobuf enum value: REFUND = 17;
   */
  REFUND = 17,
  /**
   * Indicates that the completed transaction was refunded by the merchant,
   * and that this refund was reversed. For partial refunds, we recommend that
   * you include an amount in the `value` field.
   *
   * @generated from protobuf enum value: REFUND_REVERSE = 18;
   */
  REFUND_REVERSE = 18,
}
/**
 * The request message to annotate an Assessment.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest
 */
export interface AnnotateAssessmentRequest {
  /**
   * Required. The resource name of the Assessment, in the format
   * `projects/{project}/assessments/{assessment}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * Optional. The annotation that will be assigned to the Event. This field can
   * be left empty to provide reasons that apply to an event without concluding
   * whether the event is legitimate or fraudulent.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Annotation annotation = 2;
   */
  annotation: AnnotateAssessmentRequest_Annotation;
  /**
   * Optional. Reasons for the annotation that are assigned to the event.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Reason reasons = 3;
   */
  reasons: AnnotateAssessmentRequest_Reason[];
  /**
   * Optional. A stable account identifier to apply to the assessment. This is
   * an alternative to setting `account_id` in `CreateAssessment`, for example
   * when a stable account identifier is not yet known in the initial request.
   *
   * @generated from protobuf field: string account_id = 7;
   */
  accountId: string;
  /**
   * Optional. A stable hashed account identifier to apply to the assessment.
   * This is an alternative to setting `hashed_account_id` in
   * `CreateAssessment`, for example when a stable account identifier is not yet
   * known in the initial request.
   *
   * @generated from protobuf field: bytes hashed_account_id = 4;
   */
  hashedAccountId: Uint8Array;
  /**
   * Optional. If the assessment is part of a payment transaction, provide
   * details on payment lifecycle events that occur in the transaction.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TransactionEvent transaction_event = 5;
   */
  transactionEvent?: TransactionEvent;
}
/**
 * Enum that represents the types of annotations.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Annotation
 */
export enum AnnotateAssessmentRequest_Annotation {
  /**
   * Default unspecified type.
   *
   * @generated from protobuf enum value: ANNOTATION_UNSPECIFIED = 0;
   */
  ANNOTATION_UNSPECIFIED = 0,
  /**
   * Provides information that the event turned out to be legitimate.
   *
   * @generated from protobuf enum value: LEGITIMATE = 1;
   */
  LEGITIMATE = 1,
  /**
   * Provides information that the event turned out to be fraudulent.
   *
   * @generated from protobuf enum value: FRAUDULENT = 2;
   */
  FRAUDULENT = 2,
  /**
   * Provides information that the event was related to a login event in which
   * the user typed the correct password. Deprecated, prefer indicating
   * CORRECT_PASSWORD through the reasons field instead.
   *
   * @deprecated
   * @generated from protobuf enum value: PASSWORD_CORRECT = 3 [deprecated = true];
   */
  PASSWORD_CORRECT = 3,
  /**
   * Provides information that the event was related to a login event in which
   * the user typed the incorrect password. Deprecated, prefer indicating
   * INCORRECT_PASSWORD through the reasons field instead.
   *
   * @deprecated
   * @generated from protobuf enum value: PASSWORD_INCORRECT = 4 [deprecated = true];
   */
  PASSWORD_INCORRECT = 4,
}
/**
 * Enum that represents potential reasons for annotating an assessment.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Reason
 */
export enum AnnotateAssessmentRequest_Reason {
  /**
   * Default unspecified reason.
   *
   * @generated from protobuf enum value: REASON_UNSPECIFIED = 0;
   */
  REASON_UNSPECIFIED = 0,
  /**
   * Indicates that the transaction had a chargeback issued with no other
   * details. When possible, specify the type by using CHARGEBACK_FRAUD or
   * CHARGEBACK_DISPUTE instead.
   *
   * @generated from protobuf enum value: CHARGEBACK = 1;
   */
  CHARGEBACK = 1,
  /**
   * Indicates that the transaction had a chargeback issued related to an
   * alleged unauthorized transaction from the cardholder's perspective (for
   * example, the card number was stolen).
   *
   * @generated from protobuf enum value: CHARGEBACK_FRAUD = 8;
   */
  CHARGEBACK_FRAUD = 8,
  /**
   * Indicates that the transaction had a chargeback issued related to the
   * cardholder having provided their card details but allegedly not being
   * satisfied with the purchase (for example, misrepresentation, attempted
   * cancellation).
   *
   * @generated from protobuf enum value: CHARGEBACK_DISPUTE = 9;
   */
  CHARGEBACK_DISPUTE = 9,
  /**
   * Indicates that the completed payment transaction was refunded by the
   * seller.
   *
   * @generated from protobuf enum value: REFUND = 10;
   */
  REFUND = 10,
  /**
   * Indicates that the completed payment transaction was determined to be
   * fraudulent by the seller, and was cancelled and refunded as a result.
   *
   * @generated from protobuf enum value: REFUND_FRAUD = 11;
   */
  REFUND_FRAUD = 11,
  /**
   * Indicates that the payment transaction was accepted, and the user was
   * charged.
   *
   * @generated from protobuf enum value: TRANSACTION_ACCEPTED = 12;
   */
  TRANSACTION_ACCEPTED = 12,
  /**
   * Indicates that the payment transaction was declined, for example due to
   * invalid card details.
   *
   * @generated from protobuf enum value: TRANSACTION_DECLINED = 13;
   */
  TRANSACTION_DECLINED = 13,
  /**
   * Indicates the transaction associated with the assessment is suspected of
   * being fraudulent based on the payment method, billing details, shipping
   * address or other transaction information.
   *
   * @generated from protobuf enum value: PAYMENT_HEURISTICS = 2;
   */
  PAYMENT_HEURISTICS = 2,
  /**
   * Indicates that the user was served a 2FA challenge. An old assessment
   * with `ENUM_VALUES.INITIATED_TWO_FACTOR` reason that has not been
   * overwritten with `PASSED_TWO_FACTOR` is treated as an abandoned 2FA flow.
   * This is equivalent to `FAILED_TWO_FACTOR`.
   *
   * @generated from protobuf enum value: INITIATED_TWO_FACTOR = 7;
   */
  INITIATED_TWO_FACTOR = 7,
  /**
   * Indicates that the user passed a 2FA challenge.
   *
   * @generated from protobuf enum value: PASSED_TWO_FACTOR = 3;
   */
  PASSED_TWO_FACTOR = 3,
  /**
   * Indicates that the user failed a 2FA challenge.
   *
   * @generated from protobuf enum value: FAILED_TWO_FACTOR = 4;
   */
  FAILED_TWO_FACTOR = 4,
  /**
   * Indicates the user provided the correct password.
   *
   * @generated from protobuf enum value: CORRECT_PASSWORD = 5;
   */
  CORRECT_PASSWORD = 5,
  /**
   * Indicates the user provided an incorrect password.
   *
   * @generated from protobuf enum value: INCORRECT_PASSWORD = 6;
   */
  INCORRECT_PASSWORD = 6,
  /**
   * Indicates that the user sent unwanted and abusive messages to other users
   * of the platform, such as spam, scams, phishing, or social engineering.
   *
   * @generated from protobuf enum value: SOCIAL_SPAM = 14;
   */
  SOCIAL_SPAM = 14,
}
/**
 * Empty response for AnnotateAssessment.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.AnnotateAssessmentResponse
 */
export interface AnnotateAssessmentResponse {}
/**
 * Information about a verification endpoint that can be used for 2FA.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo
 */
export interface EndpointVerificationInfo {
  /**
   * @generated from protobuf oneof: endpoint
   */
  endpoint:
    | {
        oneofKind: 'emailAddress';
        /**
         * Email address for which to trigger a verification request.
         *
         * @generated from protobuf field: string email_address = 1;
         */
        emailAddress: string;
      }
    | {
        oneofKind: 'phoneNumber';
        /**
         * Phone number for which to trigger a verification request. Should be given
         * in E.164 format.
         *
         * @generated from protobuf field: string phone_number = 2;
         */
        phoneNumber: string;
      }
    | {
        oneofKind: undefined;
      };
  /**
   * Output only. Token to provide to the client to trigger endpoint
   * verification. It must be used within 15 minutes.
   *
   * @generated from protobuf field: string request_token = 3;
   */
  requestToken: string;
  /**
   * Output only. Timestamp of the last successful verification for the
   * endpoint, if any.
   *
   * @generated from protobuf field: google.protobuf.Timestamp last_verification_time = 4;
   */
  lastVerificationTime?: Timestamp;
}
/**
 * Information about account verification, used for identity verification.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.AccountVerificationInfo
 */
export interface AccountVerificationInfo {
  /**
   * Optional. Endpoints that can be used for identity verification.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo endpoints = 1;
   */
  endpoints: EndpointVerificationInfo[];
  /**
   * Optional. Language code preference for the verification message, set as a
   * IETF BCP 47 language code.
   *
   * @generated from protobuf field: string language_code = 3;
   */
  languageCode: string;
  /**
   * Output only. Result of the latest account verification challenge.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.AccountVerificationInfo.Result latest_verification_result = 7;
   */
  latestVerificationResult: AccountVerificationInfo_Result;
  /**
   * Username of the account that is being verified. Deprecated. Customers
   * should now provide the `account_id` field in `event.user_info`.
   *
   * @deprecated
   * @generated from protobuf field: string username = 2 [deprecated = true];
   */
  username: string;
}
/**
 * Result of the account verification as contained in the verdict token issued
 * at the end of the verification flow.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.AccountVerificationInfo.Result
 */
export enum AccountVerificationInfo_Result {
  /**
   * No information about the latest account verification.
   *
   * @generated from protobuf enum value: RESULT_UNSPECIFIED = 0;
   */
  RESULT_UNSPECIFIED = 0,
  /**
   * The user was successfully verified. This means the account verification
   * challenge was successfully completed.
   *
   * @generated from protobuf enum value: SUCCESS_USER_VERIFIED = 1;
   */
  SUCCESS_USER_VERIFIED = 1,
  /**
   * The user failed the verification challenge.
   *
   * @generated from protobuf enum value: ERROR_USER_NOT_VERIFIED = 2;
   */
  ERROR_USER_NOT_VERIFIED = 2,
  /**
   * The site is not properly onboarded to use the account verification
   * feature.
   *
   * @generated from protobuf enum value: ERROR_SITE_ONBOARDING_INCOMPLETE = 3;
   */
  ERROR_SITE_ONBOARDING_INCOMPLETE = 3,
  /**
   * The recipient is not allowed for account verification. This can occur
   * during integration but should not occur in production.
   *
   * @generated from protobuf enum value: ERROR_RECIPIENT_NOT_ALLOWED = 4;
   */
  ERROR_RECIPIENT_NOT_ALLOWED = 4,
  /**
   * The recipient has already been sent too many verification codes in a
   * short amount of time.
   *
   * @generated from protobuf enum value: ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED = 5;
   */
  ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED = 5,
  /**
   * The verification flow could not be completed due to a critical internal
   * error.
   *
   * @generated from protobuf enum value: ERROR_CRITICAL_INTERNAL = 6;
   */
  ERROR_CRITICAL_INTERNAL = 6,
  /**
   * The client has exceeded their two factor request quota for this period of
   * time.
   *
   * @generated from protobuf enum value: ERROR_CUSTOMER_QUOTA_EXHAUSTED = 7;
   */
  ERROR_CUSTOMER_QUOTA_EXHAUSTED = 7,
  /**
   * The request cannot be processed at the time because of an incident. This
   * bypass can be restricted to a problematic destination email domain, a
   * customer, or could affect the entire service.
   *
   * @generated from protobuf enum value: ERROR_VERIFICATION_BYPASSED = 8;
   */
  ERROR_VERIFICATION_BYPASSED = 8,
  /**
   * The request parameters do not match with the token provided and cannot be
   * processed.
   *
   * @generated from protobuf enum value: ERROR_VERDICT_MISMATCH = 9;
   */
  ERROR_VERDICT_MISMATCH = 9,
}
/**
 * Private password leak verification info.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.PrivatePasswordLeakVerification
 */
export interface PrivatePasswordLeakVerification {
  /**
   * Required. Exactly 26-bit prefix of the SHA-256 hash of the canonicalized
   * username. It is used to look up password leaks associated with that hash
   * prefix.
   *
   * @generated from protobuf field: bytes lookup_hash_prefix = 1;
   */
  lookupHashPrefix: Uint8Array;
  /**
   * Optional. Encrypted Scrypt hash of the canonicalized username+password. It
   * is re-encrypted by the server and returned through
   * `reencrypted_user_credentials_hash`.
   *
   * @generated from protobuf field: bytes encrypted_user_credentials_hash = 2;
   */
  encryptedUserCredentialsHash: Uint8Array;
  /**
   * Output only. List of prefixes of the encrypted potential password leaks
   * that matched the given parameters. They must be compared with the
   * client-side decryption prefix of `reencrypted_user_credentials_hash`
   *
   * @generated from protobuf field: repeated bytes encrypted_leak_match_prefixes = 3;
   */
  encryptedLeakMatchPrefixes: Uint8Array[];
  /**
   * Output only. Corresponds to the re-encryption of the
   * `encrypted_user_credentials_hash` field. It is used to match potential
   * password leaks within `encrypted_leak_match_prefixes`.
   *
   * @generated from protobuf field: bytes reencrypted_user_credentials_hash = 4;
   */
  reencryptedUserCredentialsHash: Uint8Array;
}
/**
 * A reCAPTCHA Enterprise assessment resource.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.Assessment
 */
export interface Assessment {
  /**
   * Output only. Identifier. The resource name for the Assessment in the format
   * `projects/{project}/assessments/{assessment}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * Optional. The event being assessed.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.Event event = 2;
   */
  event?: Event;
  /**
   * Output only. The risk analysis result for the event being assessed.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.RiskAnalysis risk_analysis = 3;
   */
  riskAnalysis?: RiskAnalysis;
  /**
   * Output only. Properties of the provided event token.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TokenProperties token_properties = 4;
   */
  tokenProperties?: TokenProperties;
  /**
   * Optional. Account verification information for identity verification. The
   * assessment event must include a token and site key to use this feature.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.AccountVerificationInfo account_verification = 5;
   */
  accountVerification?: AccountVerificationInfo;
  /**
   * Output only. Assessment returned by account defender when an account
   * identifier is provided.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment account_defender_assessment = 6;
   */
  accountDefenderAssessment?: AccountDefenderAssessment;
  /**
   * Optional. The private password leak verification field contains the
   * parameters that are used to to check for leaks privately without sharing
   * user credentials.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.PrivatePasswordLeakVerification private_password_leak_verification = 8;
   */
  privatePasswordLeakVerification?: PrivatePasswordLeakVerification;
  /**
   * Output only. Assessment returned when firewall policies belonging to the
   * project are evaluated using the field firewall_policy_evaluation.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FirewallPolicyAssessment firewall_policy_assessment = 10;
   */
  firewallPolicyAssessment?: FirewallPolicyAssessment;
  /**
   * Output only. Assessment returned by Fraud Prevention when TransactionData
   * is provided.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment fraud_prevention_assessment = 11;
   */
  fraudPreventionAssessment?: FraudPreventionAssessment;
  /**
   * Output only. Fraud Signals specific to the users involved in a payment
   * transaction.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FraudSignals fraud_signals = 13;
   */
  fraudSignals?: FraudSignals;
  /**
   * Output only. Assessment returned when a site key, a token, and a phone
   * number as `user_id` are provided. Account defender and SMS toll fraud
   * protection need to be enabled.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.PhoneFraudAssessment phone_fraud_assessment = 12;
   */
  phoneFraudAssessment?: PhoneFraudAssessment;
  /**
   * Optional. The environment creating the assessment. This describes your
   * environment (the system invoking CreateAssessment), NOT the environment of
   * your user.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.AssessmentEnvironment assessment_environment = 14;
   */
  assessmentEnvironment?: AssessmentEnvironment;
}
/**
 * The event being assessed.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.Event
 */
export interface Event {
  /**
   * Optional. The user response token provided by the reCAPTCHA Enterprise
   * client-side integration on your site.
   *
   * @generated from protobuf field: string token = 1;
   */
  token: string;
  /**
   * Optional. The site key that was used to invoke reCAPTCHA Enterprise on your
   * site and generate the token.
   *
   * @generated from protobuf field: string site_key = 2;
   */
  siteKey: string;
  /**
   * Optional. The user agent present in the request from the user's device
   * related to this event.
   *
   * @generated from protobuf field: string user_agent = 3;
   */
  userAgent: string;
  /**
   * Optional. The IP address in the request from the user's device related to
   * this event.
   *
   * @generated from protobuf field: string user_ip_address = 4;
   */
  userIpAddress: string;
  /**
   * Optional. The expected action for this type of event. This should be the
   * same action provided at token generation time on client-side platforms
   * already integrated with recaptcha enterprise.
   *
   * @generated from protobuf field: string expected_action = 5;
   */
  expectedAction: string;
  /**
   * Optional. Deprecated: use `user_info.account_id` instead.
   * Unique stable hashed user identifier for the request. The identifier must
   * be hashed using hmac-sha256 with stable secret.
   *
   * @generated from protobuf field: bytes hashed_account_id = 6;
   */
  hashedAccountId: Uint8Array;
  /**
   * Optional. Flag for a reCAPTCHA express request for an assessment without a
   * token. If enabled, `site_key` must reference an Express site key.
   *
   * @generated from protobuf field: bool express = 14;
   */
  express: boolean;
  /**
   * Optional. The URI resource the user requested that triggered an assessment.
   *
   * @generated from protobuf field: string requested_uri = 8;
   */
  requestedUri: string;
  /**
   * Optional. Flag for running WAF token assessment.
   * If enabled, the token must be specified, and have been created by a
   * WAF-enabled key.
   *
   * @generated from protobuf field: bool waf_token_assessment = 9;
   */
  wafTokenAssessment: boolean;
  /**
   * Optional. JA3 fingerprint for SSL clients.
   *
   * @generated from protobuf field: string ja3 = 10;
   */
  ja3: string;
  /**
   * Optional. HTTP header information about the request.
   *
   * @generated from protobuf field: repeated string headers = 11;
   */
  headers: string[];
  /**
   * Optional. Flag for enabling firewall policy config assessment.
   * If this flag is enabled, the firewall policy will be evaluated and a
   * suggested firewall action will be returned in the response.
   *
   * @generated from protobuf field: bool firewall_policy_evaluation = 12;
   */
  firewallPolicyEvaluation: boolean;
  /**
   * Optional. Data describing a payment transaction to be assessed. Sending
   * this data enables reCAPTCHA Enterprise Fraud Prevention and the
   * FraudPreventionAssessment component in the response.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TransactionData transaction_data = 13;
   */
  transactionData?: TransactionData;
  /**
   * Optional. Information about the user that generates this event, when they
   * can be identified. They are often identified through the use of an account
   * for logged-in requests or login/registration requests, or by providing user
   * identifiers for guest actions like checkout.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.UserInfo user_info = 15;
   */
  userInfo?: UserInfo;
  /**
   * Optional. The Fraud Prevention setting for this assessment.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.Event.FraudPrevention fraud_prevention = 17;
   */
  fraudPrevention: Event_FraudPrevention;
}
/**
 * Setting that controls Fraud Prevention assessments.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.Event.FraudPrevention
 */
export enum Event_FraudPrevention {
  /**
   * Default, unspecified setting. If opted in for automatic detection,
   * `fraud_prevention_assessment` is returned based on the request.
   * Otherwise, `fraud_prevention_assessment` is returned if
   * `transaction_data` is present in the `Event` and Fraud Prevention is
   * enabled in the Google Cloud console.
   *
   * @generated from protobuf enum value: FRAUD_PREVENTION_UNSPECIFIED = 0;
   */
  FRAUD_PREVENTION_UNSPECIFIED = 0,
  /**
   * Enable Fraud Prevention for this assessment, if Fraud Prevention is
   * enabled in the Google Cloud console.
   *
   * @generated from protobuf enum value: ENABLED = 1;
   */
  ENABLED = 1,
  /**
   * Disable Fraud Prevention for this assessment, regardless of opt-in
   * status or Google Cloud console settings.
   *
   * @generated from protobuf enum value: DISABLED = 2;
   */
  DISABLED = 2,
}
/**
 * Transaction data associated with a payment protected by reCAPTCHA Enterprise.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.TransactionData
 */
export interface TransactionData {
  /**
   * Unique identifier for the transaction. This custom identifier can be used
   * to reference this transaction in the future, for example, labeling a refund
   * or chargeback event. Two attempts at the same transaction should use the
   * same transaction id.
   *
   * @generated from protobuf field: optional string transaction_id = 11;
   */
  transactionId?: string;
  /**
   * Optional. The payment method for the transaction. The allowed values are:
   *
   * * credit-card
   * * debit-card
   * * gift-card
   * * processor-{name} (If a third-party is used, for example,
   * processor-paypal)
   * * custom-{name} (If an alternative method is used, for example,
   * custom-crypto)
   *
   * @generated from protobuf field: string payment_method = 1;
   */
  paymentMethod: string;
  /**
   * Optional. The Bank Identification Number - generally the first 6 or 8
   * digits of the card.
   *
   * @generated from protobuf field: string card_bin = 2;
   */
  cardBin: string;
  /**
   * Optional. The last four digits of the card.
   *
   * @generated from protobuf field: string card_last_four = 3;
   */
  cardLastFour: string;
  /**
   * Optional. The currency code in ISO-4217 format.
   *
   * @generated from protobuf field: string currency_code = 4;
   */
  currencyCode: string;
  /**
   * Optional. The decimal value of the transaction in the specified currency.
   *
   * @generated from protobuf field: double value = 5;
   */
  value: number;
  /**
   * Optional. The value of shipping in the specified currency. 0 for free or no
   * shipping.
   *
   * @generated from protobuf field: double shipping_value = 12;
   */
  shippingValue: number;
  /**
   * Optional. Destination address if this transaction involves shipping a
   * physical item.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TransactionData.Address shipping_address = 6;
   */
  shippingAddress?: TransactionData_Address;
  /**
   * Optional. Address associated with the payment method when applicable.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TransactionData.Address billing_address = 7;
   */
  billingAddress?: TransactionData_Address;
  /**
   * Optional. Information about the user paying/initiating the transaction.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TransactionData.User user = 8;
   */
  user?: TransactionData_User;
  /**
   * Optional. Information about the user or users fulfilling the transaction.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.TransactionData.User merchants = 13;
   */
  merchants: TransactionData_User[];
  /**
   * Optional. Items purchased in this transaction.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.TransactionData.Item items = 14;
   */
  items: TransactionData_Item[];
  /**
   * Optional. Information about the payment gateway's response to the
   * transaction.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TransactionData.GatewayInfo gateway_info = 10;
   */
  gatewayInfo?: TransactionData_GatewayInfo;
}
/**
 * Structured address format for billing and shipping addresses.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.TransactionData.Address
 */
export interface TransactionData_Address {
  /**
   * Optional. The recipient name, potentially including information such as
   * "care of".
   *
   * @generated from protobuf field: string recipient = 1;
   */
  recipient: string;
  /**
   * Optional. The first lines of the address. The first line generally
   * contains the street name and number, and further lines may include
   * information such as an apartment number.
   *
   * @generated from protobuf field: repeated string address = 2;
   */
  address: string[];
  /**
   * Optional. The town/city of the address.
   *
   * @generated from protobuf field: string locality = 3;
   */
  locality: string;
  /**
   * Optional. The state, province, or otherwise administrative area of the
   * address.
   *
   * @generated from protobuf field: string administrative_area = 4;
   */
  administrativeArea: string;
  /**
   * Optional. The CLDR country/region of the address.
   *
   * @generated from protobuf field: string region_code = 5;
   */
  regionCode: string;
  /**
   * Optional. The postal or ZIP code of the address.
   *
   * @generated from protobuf field: string postal_code = 6;
   */
  postalCode: string;
}
/**
 * Details about a user's account involved in the transaction.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.TransactionData.User
 */
export interface TransactionData_User {
  /**
   * Optional. Unique account identifier for this user. If using account
   * defender, this should match the hashed_account_id field. Otherwise, a
   * unique and persistent identifier for this account.
   *
   * @generated from protobuf field: string account_id = 6;
   */
  accountId: string;
  /**
   * Optional. The epoch milliseconds of the user's account creation.
   *
   * @generated from protobuf field: int64 creation_ms = 1;
   */
  creationMs: bigint;
  /**
   * Optional. The email address of the user.
   *
   * @generated from protobuf field: string email = 2;
   */
  email: string;
  /**
   * Optional. Whether the email has been verified to be accessible by the
   * user (OTP or similar).
   *
   * @generated from protobuf field: bool email_verified = 3;
   */
  emailVerified: boolean;
  /**
   * Optional. The phone number of the user, with country code.
   *
   * @generated from protobuf field: string phone_number = 4;
   */
  phoneNumber: string;
  /**
   * Optional. Whether the phone number has been verified to be accessible by
   * the user (OTP or similar).
   *
   * @generated from protobuf field: bool phone_verified = 5;
   */
  phoneVerified: boolean;
}
/**
 * Line items being purchased in this transaction.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.TransactionData.Item
 */
export interface TransactionData_Item {
  /**
   * Optional. The full name of the item.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * Optional. The value per item that the user is paying, in the transaction
   * currency, after discounts.
   *
   * @generated from protobuf field: double value = 2;
   */
  value: number;
  /**
   * Optional. The quantity of this item that is being purchased.
   *
   * @generated from protobuf field: int64 quantity = 3;
   */
  quantity: bigint;
  /**
   * Optional. When a merchant is specified, its corresponding account_id.
   * Necessary to populate marketplace-style transactions.
   *
   * @generated from protobuf field: string merchant_account_id = 4;
   */
  merchantAccountId: string;
}
/**
 * Details about the transaction from the gateway.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.TransactionData.GatewayInfo
 */
export interface TransactionData_GatewayInfo {
  /**
   * Optional. Name of the gateway service (for example, stripe, square,
   * paypal).
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * Optional. Gateway response code describing the state of the transaction.
   *
   * @generated from protobuf field: string gateway_response_code = 2;
   */
  gatewayResponseCode: string;
  /**
   * Optional. AVS response code from the gateway
   * (available only when reCAPTCHA Enterprise is called after authorization).
   *
   * @generated from protobuf field: string avs_response_code = 3;
   */
  avsResponseCode: string;
  /**
   * Optional. CVV response code from the gateway
   * (available only when reCAPTCHA Enterprise is called after authorization).
   *
   * @generated from protobuf field: string cvv_response_code = 4;
   */
  cvvResponseCode: string;
}
/**
 * User information associated with a request protected by reCAPTCHA Enterprise.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.UserInfo
 */
export interface UserInfo {
  /**
   * Optional. Creation time for this account associated with this user. Leave
   * blank for non logged-in actions, guest checkout, or when there is no
   * account associated with the current user.
   *
   * @generated from protobuf field: google.protobuf.Timestamp create_account_time = 1;
   */
  createAccountTime?: Timestamp;
  /**
   * Optional. For logged-in requests or login/registration requests, the unique
   * account identifier associated with this user. You can use the username if
   * it is stable (meaning it is the same for every request associated with the
   * same user), or any stable user ID of your choice. Leave blank for non
   * logged-in actions or guest checkout.
   *
   * @generated from protobuf field: string account_id = 2;
   */
  accountId: string;
  /**
   * Optional. Identifiers associated with this user or request.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.UserId user_ids = 3;
   */
  userIds: UserId[];
}
/**
 * An identifier associated with a user.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.UserId
 */
export interface UserId {
  /**
   * @generated from protobuf oneof: id_oneof
   */
  idOneof:
    | {
        oneofKind: 'email';
        /**
         * Optional. An email address.
         *
         * @generated from protobuf field: string email = 1;
         */
        email: string;
      }
    | {
        oneofKind: 'phoneNumber';
        /**
         * Optional. A phone number. Should use the E.164 format.
         *
         * @generated from protobuf field: string phone_number = 2;
         */
        phoneNumber: string;
      }
    | {
        oneofKind: 'username';
        /**
         * Optional. A unique username, if different from all the other identifiers
         * and `account_id` that are provided. Can be a unique login handle or
         * display name for a user.
         *
         * @generated from protobuf field: string username = 3;
         */
        username: string;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * Risk analysis result for an event.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.RiskAnalysis
 */
export interface RiskAnalysis {
  /**
   * Output only. Legitimate event score from 0.0 to 1.0.
   * (1.0 means very likely legitimate traffic while 0.0 means very likely
   * non-legitimate traffic).
   *
   * @generated from protobuf field: float score = 1;
   */
  score: number;
  /**
   * Output only. Reasons contributing to the risk analysis verdict.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.RiskAnalysis.ClassificationReason reasons = 2;
   */
  reasons: RiskAnalysis_ClassificationReason[];
  /**
   * Output only. Extended verdict reasons to be used for experimentation only.
   * The set of possible reasons is subject to change.
   *
   * @generated from protobuf field: repeated string extended_verdict_reasons = 3;
   */
  extendedVerdictReasons: string[];
}
/**
 * Reasons contributing to the risk analysis verdict.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.RiskAnalysis.ClassificationReason
 */
export enum RiskAnalysis_ClassificationReason {
  /**
   * Default unspecified type.
   *
   * @generated from protobuf enum value: CLASSIFICATION_REASON_UNSPECIFIED = 0;
   */
  CLASSIFICATION_REASON_UNSPECIFIED = 0,
  /**
   * Interactions matched the behavior of an automated agent.
   *
   * @generated from protobuf enum value: AUTOMATION = 1;
   */
  AUTOMATION = 1,
  /**
   * The event originated from an illegitimate environment.
   *
   * @generated from protobuf enum value: UNEXPECTED_ENVIRONMENT = 2;
   */
  UNEXPECTED_ENVIRONMENT = 2,
  /**
   * Traffic volume from the event source is higher than normal.
   *
   * @generated from protobuf enum value: TOO_MUCH_TRAFFIC = 3;
   */
  TOO_MUCH_TRAFFIC = 3,
  /**
   * Interactions with the site were significantly different than expected
   * patterns.
   *
   * @generated from protobuf enum value: UNEXPECTED_USAGE_PATTERNS = 4;
   */
  UNEXPECTED_USAGE_PATTERNS = 4,
  /**
   * Too little traffic has been received from this site thus far to generate
   * quality risk analysis.
   *
   * @generated from protobuf enum value: LOW_CONFIDENCE_SCORE = 5;
   */
  LOW_CONFIDENCE_SCORE = 5,
  /**
   * The request matches behavioral characteristics of a carding attack.
   *
   * @generated from protobuf enum value: SUSPECTED_CARDING = 6;
   */
  SUSPECTED_CARDING = 6,
  /**
   * The request matches behavioral characteristics of chargebacks for fraud.
   *
   * @generated from protobuf enum value: SUSPECTED_CHARGEBACK = 7;
   */
  SUSPECTED_CHARGEBACK = 7,
}
/**
 * Properties of the provided event token.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.TokenProperties
 */
export interface TokenProperties {
  /**
   * Output only. Whether the provided user response token is valid. When valid
   * = false, the reason could be specified in invalid_reason or it could also
   * be due to a user failing to solve a challenge or a sitekey mismatch (i.e
   * the sitekey used to generate the token was different than the one specified
   * in the assessment).
   *
   * @generated from protobuf field: bool valid = 1;
   */
  valid: boolean;
  /**
   * Output only. Reason associated with the response when valid = false.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TokenProperties.InvalidReason invalid_reason = 2;
   */
  invalidReason: TokenProperties_InvalidReason;
  /**
   * Output only. The timestamp corresponding to the generation of the token.
   *
   * @generated from protobuf field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;
  /**
   * Output only. The hostname of the page on which the token was generated (Web
   * keys only).
   *
   * @generated from protobuf field: string hostname = 4;
   */
  hostname: string;
  /**
   * Output only. The name of the Android package with which the token was
   * generated (Android keys only).
   *
   * @generated from protobuf field: string android_package_name = 8;
   */
  androidPackageName: string;
  /**
   * Output only. The ID of the iOS bundle with which the token was generated
   * (iOS keys only).
   *
   * @generated from protobuf field: string ios_bundle_id = 9;
   */
  iosBundleId: string;
  /**
   * Output only. Action name provided at token generation.
   *
   * @generated from protobuf field: string action = 5;
   */
  action: string;
}
/**
 * Enum that represents the types of invalid token reasons.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.TokenProperties.InvalidReason
 */
export enum TokenProperties_InvalidReason {
  /**
   * Default unspecified type.
   *
   * @generated from protobuf enum value: INVALID_REASON_UNSPECIFIED = 0;
   */
  INVALID_REASON_UNSPECIFIED = 0,
  /**
   * If the failure reason was not accounted for.
   *
   * @generated from protobuf enum value: UNKNOWN_INVALID_REASON = 1;
   */
  UNKNOWN_INVALID_REASON = 1,
  /**
   * The provided user verification token was malformed.
   *
   * @generated from protobuf enum value: MALFORMED = 2;
   */
  MALFORMED = 2,
  /**
   * The user verification token had expired.
   *
   * @generated from protobuf enum value: EXPIRED = 3;
   */
  EXPIRED = 3,
  /**
   * The user verification had already been seen.
   *
   * @generated from protobuf enum value: DUPE = 4;
   */
  DUPE = 4,
  /**
   * The user verification token was not present.
   *
   * @generated from protobuf enum value: MISSING = 5;
   */
  MISSING = 5,
  /**
   * A retriable error (such as network failure) occurred on the browser.
   * Could easily be simulated by an attacker.
   *
   * @generated from protobuf enum value: BROWSER_ERROR = 6;
   */
  BROWSER_ERROR = 6,
}
/**
 * Assessment for Fraud Prevention.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment
 */
export interface FraudPreventionAssessment {
  /**
   * Output only. Probability of this transaction being fraudulent. Summarizes
   * the combined risk of attack vectors below. Values are from 0.0 (lowest)
   * to 1.0 (highest).
   *
   * @generated from protobuf field: float transaction_risk = 1;
   */
  transactionRisk: number;
  /**
   * Output only. Assessment of this transaction for risk of a stolen
   * instrument.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.StolenInstrumentVerdict stolen_instrument_verdict = 2;
   */
  stolenInstrumentVerdict?: FraudPreventionAssessment_StolenInstrumentVerdict;
  /**
   * Output only. Assessment of this transaction for risk of being part of a
   * card testing attack.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.CardTestingVerdict card_testing_verdict = 3;
   */
  cardTestingVerdict?: FraudPreventionAssessment_CardTestingVerdict;
  /**
   * Output only. Assessment of this transaction for behavioral trust.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.BehavioralTrustVerdict behavioral_trust_verdict = 4;
   */
  behavioralTrustVerdict?: FraudPreventionAssessment_BehavioralTrustVerdict;
}
/**
 * Information about stolen instrument fraud, where the user is not the
 * legitimate owner of the instrument being used for the purchase.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.StolenInstrumentVerdict
 */
export interface FraudPreventionAssessment_StolenInstrumentVerdict {
  /**
   * Output only. Probability of this transaction being executed with a stolen
   * instrument. Values are from 0.0 (lowest) to 1.0 (highest).
   *
   * @generated from protobuf field: float risk = 1;
   */
  risk: number;
}
/**
 * Information about card testing fraud, where an adversary is testing
 * fraudulently obtained cards or brute forcing their details.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.CardTestingVerdict
 */
export interface FraudPreventionAssessment_CardTestingVerdict {
  /**
   * Output only. Probability of this transaction attempt being part of a card
   * testing attack. Values are from 0.0 (lowest) to 1.0 (highest).
   *
   * @generated from protobuf field: float risk = 1;
   */
  risk: number;
}
/**
 * Information about behavioral trust of the transaction.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.BehavioralTrustVerdict
 */
export interface FraudPreventionAssessment_BehavioralTrustVerdict {
  /**
   * Output only. Probability of this transaction attempt being executed in a
   * behaviorally trustworthy way. Values are from 0.0 (lowest) to 1.0
   * (highest).
   *
   * @generated from protobuf field: float trust = 1;
   */
  trust: number;
}
/**
 * Fraud signals describing users and cards involved in the transaction.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FraudSignals
 */
export interface FraudSignals {
  /**
   * Output only. Signals describing the end user in this transaction.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FraudSignals.UserSignals user_signals = 1;
   */
  userSignals?: FraudSignals_UserSignals;
  /**
   * Output only. Signals describing the payment card or cards used in this
   * transaction.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals card_signals = 2;
   */
  cardSignals?: FraudSignals_CardSignals;
}
/**
 * Signals describing the user involved in this transaction.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FraudSignals.UserSignals
 */
export interface FraudSignals_UserSignals {
  /**
   * Output only. This user (based on email, phone, and other identifiers) has
   * been seen on the internet for at least this number of days.
   *
   * @generated from protobuf field: int32 active_days_lower_bound = 1;
   */
  activeDaysLowerBound: number;
  /**
   * Output only. Likelihood (from 0.0 to 1.0) this user includes synthetic
   * components in their identity, such as a randomly generated email address,
   * temporary phone number, or fake shipping address.
   *
   * @generated from protobuf field: float synthetic_risk = 2;
   */
  syntheticRisk: number;
}
/**
 * Signals describing the payment card used in this transaction.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals
 */
export interface FraudSignals_CardSignals {
  /**
   * Output only. The labels for the payment card in this transaction.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals.CardLabel card_labels = 1;
   */
  cardLabels: FraudSignals_CardSignals_CardLabel[];
}
/**
 * Risk labels describing the card being assessed, such as its funding
 * mechanism.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals.CardLabel
 */
export enum FraudSignals_CardSignals_CardLabel {
  /**
   * No label specified.
   *
   * @generated from protobuf enum value: CARD_LABEL_UNSPECIFIED = 0;
   */
  CARD_LABEL_UNSPECIFIED = 0,
  /**
   * This card has been detected as prepaid.
   *
   * @generated from protobuf enum value: PREPAID = 1;
   */
  PREPAID = 1,
  /**
   * This card has been detected as virtual, such as a card number generated
   * for a single transaction or merchant.
   *
   * @generated from protobuf enum value: VIRTUAL = 2;
   */
  VIRTUAL = 2,
  /**
   * This card has been detected as being used in an unexpected geographic
   * location.
   *
   * @generated from protobuf enum value: UNEXPECTED_LOCATION = 3;
   */
  UNEXPECTED_LOCATION = 3,
}
/**
 * Information about SMS toll fraud.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict
 */
export interface SmsTollFraudVerdict {
  /**
   * Output only. Probability of an SMS event being fraudulent.
   * Values are from 0.0 (lowest) to 1.0 (highest).
   *
   * @generated from protobuf field: float risk = 1;
   */
  risk: number;
  /**
   * Output only. Reasons contributing to the SMS toll fraud verdict.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict.SmsTollFraudReason reasons = 2;
   */
  reasons: SmsTollFraudVerdict_SmsTollFraudReason[];
}
/**
 * Reasons contributing to the SMS toll fraud verdict.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict.SmsTollFraudReason
 */
export enum SmsTollFraudVerdict_SmsTollFraudReason {
  /**
   * Default unspecified reason
   *
   * @generated from protobuf enum value: SMS_TOLL_FRAUD_REASON_UNSPECIFIED = 0;
   */
  SMS_TOLL_FRAUD_REASON_UNSPECIFIED = 0,
  /**
   * The provided phone number was invalid
   *
   * @generated from protobuf enum value: INVALID_PHONE_NUMBER = 1;
   */
  INVALID_PHONE_NUMBER = 1,
}
/**
 * Assessment for Phone Fraud
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.PhoneFraudAssessment
 */
export interface PhoneFraudAssessment {
  /**
   * Output only. Assessment of this phone event for risk of SMS toll fraud.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict sms_toll_fraud_verdict = 1;
   */
  smsTollFraudVerdict?: SmsTollFraudVerdict;
}
/**
 * Account defender risk assessment.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment
 */
export interface AccountDefenderAssessment {
  /**
   * Output only. Labels for this request.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment.AccountDefenderLabel labels = 1;
   */
  labels: AccountDefenderAssessment_AccountDefenderLabel[];
}
/**
 * Labels returned by account defender for this request.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment.AccountDefenderLabel
 */
export enum AccountDefenderAssessment_AccountDefenderLabel {
  /**
   * Default unspecified type.
   *
   * @generated from protobuf enum value: ACCOUNT_DEFENDER_LABEL_UNSPECIFIED = 0;
   */
  ACCOUNT_DEFENDER_LABEL_UNSPECIFIED = 0,
  /**
   * The request matches a known good profile for the user.
   *
   * @generated from protobuf enum value: PROFILE_MATCH = 1;
   */
  PROFILE_MATCH = 1,
  /**
   * The request is potentially a suspicious login event and must be further
   * verified either through multi-factor authentication or another system.
   *
   * @generated from protobuf enum value: SUSPICIOUS_LOGIN_ACTIVITY = 2;
   */
  SUSPICIOUS_LOGIN_ACTIVITY = 2,
  /**
   * The request matched a profile that previously had suspicious account
   * creation behavior. This can mean that this is a fake account.
   *
   * @generated from protobuf enum value: SUSPICIOUS_ACCOUNT_CREATION = 3;
   */
  SUSPICIOUS_ACCOUNT_CREATION = 3,
  /**
   * The account in the request has a high number of related accounts. It does
   * not necessarily imply that the account is bad but can require further
   * investigation.
   *
   * @generated from protobuf enum value: RELATED_ACCOUNTS_NUMBER_HIGH = 4;
   */
  RELATED_ACCOUNTS_NUMBER_HIGH = 4,
}
/**
 * The create key request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.CreateKeyRequest
 */
export interface CreateKeyRequest {
  /**
   * Required. The name of the project in which the key will be created, in the
   * format `projects/{project}`.
   *
   * @generated from protobuf field: string parent = 1;
   */
  parent: string;
  /**
   * Required. Information to create a reCAPTCHA Enterprise key.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.Key key = 2;
   */
  key?: Key;
}
/**
 * The list keys request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ListKeysRequest
 */
export interface ListKeysRequest {
  /**
   * Required. The name of the project that contains the keys that will be
   * listed, in the format `projects/{project}`.
   *
   * @generated from protobuf field: string parent = 1;
   */
  parent: string;
  /**
   * Optional. The maximum number of keys to return. Default is 10. Max limit is
   * 1000.
   *
   * @generated from protobuf field: int32 page_size = 2;
   */
  pageSize: number;
  /**
   * Optional. The next_page_token value returned from a previous.
   * ListKeysRequest, if any.
   *
   * @generated from protobuf field: string page_token = 3;
   */
  pageToken: string;
}
/**
 * Response to request to list keys in a project.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ListKeysResponse
 */
export interface ListKeysResponse {
  /**
   * Key details.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.Key keys = 1;
   */
  keys: Key[];
  /**
   * Token to retrieve the next page of results. It is set to empty if no keys
   * remain in results.
   *
   * @generated from protobuf field: string next_page_token = 2;
   */
  nextPageToken: string;
}
/**
 * The retrieve legacy secret key request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyRequest
 */
export interface RetrieveLegacySecretKeyRequest {
  /**
   * Required. The public key name linked to the requested secret key in the
   * format `projects/{project}/keys/{key}`.
   *
   * @generated from protobuf field: string key = 1;
   */
  key: string;
}
/**
 * The get key request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.GetKeyRequest
 */
export interface GetKeyRequest {
  /**
   * Required. The name of the requested key, in the format
   * `projects/{project}/keys/{key}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
}
/**
 * The update key request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.UpdateKeyRequest
 */
export interface UpdateKeyRequest {
  /**
   * Required. The key to update.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.Key key = 1;
   */
  key?: Key;
  /**
   * Optional. The mask to control which fields of the key get updated. If the
   * mask is not present, all fields will be updated.
   *
   * @generated from protobuf field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
}
/**
 * The delete key request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.DeleteKeyRequest
 */
export interface DeleteKeyRequest {
  /**
   * Required. The name of the key to be deleted, in the format
   * `projects/{project}/keys/{key}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
}
/**
 * The create firewall policy request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.CreateFirewallPolicyRequest
 */
export interface CreateFirewallPolicyRequest {
  /**
   * Required. The name of the project this policy will apply to, in the format
   * `projects/{project}`.
   *
   * @generated from protobuf field: string parent = 1;
   */
  parent: string;
  /**
   * Required. Information to create the policy.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policy = 2;
   */
  firewallPolicy?: FirewallPolicy;
}
/**
 * The list firewall policies request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesRequest
 */
export interface ListFirewallPoliciesRequest {
  /**
   * Required. The name of the project to list the policies for, in the format
   * `projects/{project}`.
   *
   * @generated from protobuf field: string parent = 1;
   */
  parent: string;
  /**
   * Optional. The maximum number of policies to return. Default is 10. Max
   * limit is 1000.
   *
   * @generated from protobuf field: int32 page_size = 2;
   */
  pageSize: number;
  /**
   * Optional. The next_page_token value returned from a previous.
   * ListFirewallPoliciesRequest, if any.
   *
   * @generated from protobuf field: string page_token = 3;
   */
  pageToken: string;
}
/**
 * Response to request to list firewall policies belonging to a project.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesResponse
 */
export interface ListFirewallPoliciesResponse {
  /**
   * Policy details.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policies = 1;
   */
  firewallPolicies: FirewallPolicy[];
  /**
   * Token to retrieve the next page of results. It is set to empty if no
   * policies remain in results.
   *
   * @generated from protobuf field: string next_page_token = 2;
   */
  nextPageToken: string;
}
/**
 * The get firewall policy request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.GetFirewallPolicyRequest
 */
export interface GetFirewallPolicyRequest {
  /**
   * Required. The name of the requested policy, in the format
   * `projects/{project}/firewallpolicies/{firewallpolicy}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
}
/**
 * The update firewall policy request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.UpdateFirewallPolicyRequest
 */
export interface UpdateFirewallPolicyRequest {
  /**
   * Required. The policy to update.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policy = 1;
   */
  firewallPolicy?: FirewallPolicy;
  /**
   * Optional. The mask to control which fields of the policy get updated. If
   * the mask is not present, all fields will be updated.
   *
   * @generated from protobuf field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
}
/**
 * The delete firewall policy request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.DeleteFirewallPolicyRequest
 */
export interface DeleteFirewallPolicyRequest {
  /**
   * Required. The name of the policy to be deleted, in the format
   * `projects/{project}/firewallpolicies/{firewallpolicy}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
}
/**
 * The reorder firewall policies request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesRequest
 */
export interface ReorderFirewallPoliciesRequest {
  /**
   * Required. The name of the project to list the policies for, in the format
   * `projects/{project}`.
   *
   * @generated from protobuf field: string parent = 1;
   */
  parent: string;
  /**
   * Required. A list containing all policy names, in the new order. Each name
   * is in the format `projects/{project}/firewallpolicies/{firewallpolicy}`.
   *
   * @generated from protobuf field: repeated string names = 2;
   */
  names: string[];
}
/**
 * The reorder firewall policies response message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesResponse
 */
export interface ReorderFirewallPoliciesResponse {}
/**
 * The migrate key request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.MigrateKeyRequest
 */
export interface MigrateKeyRequest {
  /**
   * Required. The name of the key to be migrated, in the format
   * `projects/{project}/keys/{key}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * Optional. If true, skips the billing check.
   * A reCAPTCHA Enterprise key or migrated key behaves differently than a
   * reCAPTCHA (non-Enterprise version) key when you reach a quota limit (see
   * https://cloud.google.com/recaptcha/quotas#quota_limit). To avoid
   * any disruption of your usage, we check that a billing account is present.
   * If your usage of reCAPTCHA is under the free quota, you can safely skip the
   * billing check and proceed with the migration. See
   * https://cloud.google.com/recaptcha/docs/billing-information.
   *
   * @generated from protobuf field: bool skip_billing_check = 2;
   */
  skipBillingCheck: boolean;
}
/**
 * The get metrics request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.GetMetricsRequest
 */
export interface GetMetricsRequest {
  /**
   * Required. The name of the requested metrics, in the format
   * `projects/{project}/keys/{key}/metrics`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
}
/**
 * Metrics for a single Key.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.Metrics
 */
export interface Metrics {
  /**
   * Output only. Identifier. The name of the metrics, in the format
   * `projects/{project}/keys/{key}/metrics`.
   *
   * @generated from protobuf field: string name = 4;
   */
  name: string;
  /**
   * Inclusive start time aligned to a day (UTC).
   *
   * @generated from protobuf field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;
  /**
   * Metrics will be continuous and in order by dates, and in the granularity
   * of day. All Key types should have score-based data.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.ScoreMetrics score_metrics = 2;
   */
  scoreMetrics: ScoreMetrics[];
  /**
   * Metrics will be continuous and in order by dates, and in the granularity
   * of day. Only challenge-based keys (CHECKBOX, INVISIBLE), will have
   * challenge-based data.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.ChallengeMetrics challenge_metrics = 3;
   */
  challengeMetrics: ChallengeMetrics[];
}
/**
 * Secret key is used only in legacy reCAPTCHA. It must be used in a 3rd party
 * integration with legacy reCAPTCHA.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyResponse
 */
export interface RetrieveLegacySecretKeyResponse {
  /**
   * The secret key (also known as shared secret) authorizes communication
   * between your application backend and the reCAPTCHA Enterprise server to
   * create an assessment.
   * The secret key needs to be kept safe for security purposes.
   *
   * @generated from protobuf field: string legacy_secret_key = 1;
   */
  legacySecretKey: string;
}
/**
 * A key used to identify and configure applications (web and/or mobile) that
 * use reCAPTCHA Enterprise.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.Key
 */
export interface Key {
  /**
   * Identifier. The resource name for the Key in the format
   * `projects/{project}/keys/{key}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * Required. Human-readable display name of this key. Modifiable by user.
   *
   * @generated from protobuf field: string display_name = 2;
   */
  displayName: string;
  /**
   * @generated from protobuf oneof: platform_settings
   */
  platformSettings:
    | {
        oneofKind: 'webSettings';
        /**
         * Settings for keys that can be used by websites.
         *
         * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.WebKeySettings web_settings = 3;
         */
        webSettings: WebKeySettings;
      }
    | {
        oneofKind: 'androidSettings';
        /**
         * Settings for keys that can be used by Android apps.
         *
         * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.AndroidKeySettings android_settings = 4;
         */
        androidSettings: AndroidKeySettings;
      }
    | {
        oneofKind: 'iosSettings';
        /**
         * Settings for keys that can be used by iOS apps.
         *
         * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.IOSKeySettings ios_settings = 5;
         */
        iosSettings: IOSKeySettings;
      }
    | {
        oneofKind: 'expressSettings';
        /**
         * Settings for keys that can be used by reCAPTCHA Express.
         *
         * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.ExpressKeySettings express_settings = 11;
         */
        expressSettings: ExpressKeySettings;
      }
    | {
        oneofKind: undefined;
      };
  /**
   * Optional. See [Creating and managing labels]
   * (https://cloud.google.com/recaptcha/docs/labels).
   *
   * @generated from protobuf field: map<string, string> labels = 6;
   */
  labels: {
    [key: string]: string;
  };
  /**
   * Output only. The timestamp corresponding to the creation of this key.
   *
   * @generated from protobuf field: google.protobuf.Timestamp create_time = 7;
   */
  createTime?: Timestamp;
  /**
   * Optional. Options for user acceptance testing.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TestingOptions testing_options = 9;
   */
  testingOptions?: TestingOptions;
  /**
   * Optional. Settings for WAF
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.WafSettings waf_settings = 10;
   */
  wafSettings?: WafSettings;
}
/**
 * Options for user acceptance testing.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.TestingOptions
 */
export interface TestingOptions {
  /**
   * Optional. All assessments for this Key will return this score. Must be
   * between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.
   *
   * @generated from protobuf field: float testing_score = 1;
   */
  testingScore: number;
  /**
   * Optional. For challenge-based keys only (CHECKBOX, INVISIBLE), all
   * challenge requests for this site will return nocaptcha if NOCAPTCHA, or an
   * unsolvable challenge if CHALLENGE.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.TestingOptions.TestingChallenge testing_challenge = 2;
   */
  testingChallenge: TestingOptions_TestingChallenge;
}
/**
 * Enum that represents the challenge option for challenge-based (CHECKBOX,
 * INVISIBLE) testing keys.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.TestingOptions.TestingChallenge
 */
export enum TestingOptions_TestingChallenge {
  /**
   * Perform the normal risk analysis and return either nocaptcha or a
   * challenge depending on risk and trust factors.
   *
   * @generated from protobuf enum value: TESTING_CHALLENGE_UNSPECIFIED = 0;
   */
  TESTING_CHALLENGE_UNSPECIFIED = 0,
  /**
   * Challenge requests for this key always return a nocaptcha, which
   * does not require a solution.
   *
   * @generated from protobuf enum value: NOCAPTCHA = 1;
   */
  NOCAPTCHA = 1,
  /**
   * Challenge requests for this key always return an unsolvable
   * challenge.
   *
   * @generated from protobuf enum value: UNSOLVABLE_CHALLENGE = 2;
   */
  UNSOLVABLE_CHALLENGE = 2,
}
/**
 * Settings specific to keys that can be used by websites.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.WebKeySettings
 */
export interface WebKeySettings {
  /**
   * Optional. If set to true, it means allowed_domains will not be enforced.
   *
   * @generated from protobuf field: bool allow_all_domains = 3;
   */
  allowAllDomains: boolean;
  /**
   * Optional. Domains or subdomains of websites allowed to use the key. All
   * subdomains of an allowed domain are automatically allowed. A valid domain
   * requires a host and must not include any path, port, query or fragment.
   * Examples: 'example.com' or 'subdomain.example.com'
   *
   * @generated from protobuf field: repeated string allowed_domains = 1;
   */
  allowedDomains: string[];
  /**
   * Optional. If set to true, the key can be used on AMP (Accelerated Mobile
   * Pages) websites. This is supported only for the SCORE integration type.
   *
   * @generated from protobuf field: bool allow_amp_traffic = 2;
   */
  allowAmpTraffic: boolean;
  /**
   * Required. Describes how this key is integrated with the website.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.WebKeySettings.IntegrationType integration_type = 4;
   */
  integrationType: WebKeySettings_IntegrationType;
  /**
   * Optional. Settings for the frequency and difficulty at which this key
   * triggers captcha challenges. This should only be specified for
   * IntegrationTypes CHECKBOX and INVISIBLE.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.WebKeySettings.ChallengeSecurityPreference challenge_security_preference = 5;
   */
  challengeSecurityPreference: WebKeySettings_ChallengeSecurityPreference;
}
/**
 * Enum that represents the integration types for web keys.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.WebKeySettings.IntegrationType
 */
export enum WebKeySettings_IntegrationType {
  /**
   * Default type that indicates this enum hasn't been specified. This is not
   * a valid IntegrationType, one of the other types must be specified
   * instead.
   *
   * @generated from protobuf enum value: INTEGRATION_TYPE_UNSPECIFIED = 0;
   */
  INTEGRATION_TYPE_UNSPECIFIED = 0,
  /**
   * Only used to produce scores. It doesn't display the "I'm not a robot"
   * checkbox and never shows captcha challenges.
   *
   * @generated from protobuf enum value: SCORE = 1;
   */
  SCORE = 1,
  /**
   * Displays the "I'm not a robot" checkbox and may show captcha challenges
   * after it is checked.
   *
   * @generated from protobuf enum value: CHECKBOX = 2;
   */
  CHECKBOX = 2,
  /**
   * Doesn't display the "I'm not a robot" checkbox, but may show captcha
   * challenges after risk analysis.
   *
   * @generated from protobuf enum value: INVISIBLE = 3;
   */
  INVISIBLE = 3,
}
/**
 * Enum that represents the possible challenge frequency and difficulty
 * configurations for a web key.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.WebKeySettings.ChallengeSecurityPreference
 */
export enum WebKeySettings_ChallengeSecurityPreference {
  /**
   * Default type that indicates this enum hasn't been specified.
   *
   * @generated from protobuf enum value: CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED = 0;
   */
  CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED = 0,
  /**
   * Key tends to show fewer and easier challenges.
   *
   * @generated from protobuf enum value: USABILITY = 1;
   */
  USABILITY = 1,
  /**
   * Key tends to show balanced (in amount and difficulty) challenges.
   *
   * @generated from protobuf enum value: BALANCE = 2;
   */
  BALANCE = 2,
  /**
   * Key tends to show more and harder challenges.
   *
   * @generated from protobuf enum value: SECURITY = 3;
   */
  SECURITY = 3,
}
/**
 * Settings specific to keys that can be used by Android apps.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.AndroidKeySettings
 */
export interface AndroidKeySettings {
  /**
   * Optional. If set to true, allowed_package_names are not enforced.
   *
   * @generated from protobuf field: bool allow_all_package_names = 2;
   */
  allowAllPackageNames: boolean;
  /**
   * Optional. Android package names of apps allowed to use the key.
   * Example: 'com.companyname.appname'
   *
   * @generated from protobuf field: repeated string allowed_package_names = 1;
   */
  allowedPackageNames: string[];
  /**
   * Optional. Set to true for keys that are used in an Android application that
   * is available for download in app stores in addition to the Google Play
   * Store.
   *
   * @generated from protobuf field: bool support_non_google_app_store_distribution = 3;
   */
  supportNonGoogleAppStoreDistribution: boolean;
}
/**
 * Settings specific to keys that can be used by iOS apps.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.IOSKeySettings
 */
export interface IOSKeySettings {
  /**
   * Optional. If set to true, allowed_bundle_ids are not enforced.
   *
   * @generated from protobuf field: bool allow_all_bundle_ids = 2;
   */
  allowAllBundleIds: boolean;
  /**
   * Optional. iOS bundle ids of apps allowed to use the key.
   * Example: 'com.companyname.productname.appname'
   *
   * @generated from protobuf field: repeated string allowed_bundle_ids = 1;
   */
  allowedBundleIds: string[];
  /**
   * Optional. Apple Developer account details for the app that is protected by
   * the reCAPTCHA Key. reCAPTCHA Enterprise leverages platform-specific checks
   * like Apple App Attest and Apple DeviceCheck to protect your app from abuse.
   * Providing these fields allows reCAPTCHA Enterprise to get a better
   * assessment of the integrity of your app.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.AppleDeveloperId apple_developer_id = 3;
   */
  appleDeveloperId?: AppleDeveloperId;
}
/**
 * Settings specific to keys that can be used for reCAPTCHA Express.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ExpressKeySettings
 */
export interface ExpressKeySettings {}
/**
 * Contains fields that are required to perform Apple-specific integrity checks.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.AppleDeveloperId
 */
export interface AppleDeveloperId {
  /**
   * Required. Input only. A private key (downloaded as a text file with a .p8
   * file extension) generated for your Apple Developer account. Ensure that
   * Apple DeviceCheck is enabled for the private key.
   *
   * @generated from protobuf field: string private_key = 1;
   */
  privateKey: string;
  /**
   * Required. The Apple developer key ID (10-character string).
   *
   * @generated from protobuf field: string key_id = 2;
   */
  keyId: string;
  /**
   * Required. The Apple team ID (10-character string) owning the provisioning
   * profile used to build your application.
   *
   * @generated from protobuf field: string team_id = 3;
   */
  teamId: string;
}
/**
 * Score distribution.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ScoreDistribution
 */
export interface ScoreDistribution {
  /**
   * Map key is score value multiplied by 100. The scores are discrete values
   * between [0, 1]. The maximum number of buckets is on order of a few dozen,
   * but typically much lower (ie. 10).
   *
   * @generated from protobuf field: map<int32, int64> score_buckets = 1;
   */
  scoreBuckets: {
    [key: number]: bigint;
  };
}
/**
 * Metrics related to scoring.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ScoreMetrics
 */
export interface ScoreMetrics {
  /**
   * Aggregated score metrics for all traffic.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.ScoreDistribution overall_metrics = 1;
   */
  overallMetrics?: ScoreDistribution;
  /**
   * Action-based metrics. The map key is the action name which specified by the
   * site owners at time of the "execute" client-side call.
   *
   * @generated from protobuf field: map<string, google.cloud.recaptchaenterprise.v1.ScoreDistribution> action_metrics = 2;
   */
  actionMetrics: {
    [key: string]: ScoreDistribution;
  };
}
/**
 * Metrics related to challenges.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ChallengeMetrics
 */
export interface ChallengeMetrics {
  /**
   * Count of reCAPTCHA checkboxes or badges rendered. This is mostly equivalent
   * to a count of pageloads for pages that include reCAPTCHA.
   *
   * @generated from protobuf field: int64 pageload_count = 1;
   */
  pageloadCount: bigint;
  /**
   * Count of nocaptchas (successful verification without a challenge) issued.
   *
   * @generated from protobuf field: int64 nocaptcha_count = 2;
   */
  nocaptchaCount: bigint;
  /**
   * Count of submitted challenge solutions that were incorrect or otherwise
   * deemed suspicious such that a subsequent challenge was triggered.
   *
   * @generated from protobuf field: int64 failed_count = 3;
   */
  failedCount: bigint;
  /**
   * Count of nocaptchas (successful verification without a challenge) plus
   * submitted challenge solutions that were correct and resulted in
   * verification.
   *
   * @generated from protobuf field: int64 passed_count = 4;
   */
  passedCount: bigint;
}
/**
 * Policy config assessment.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FirewallPolicyAssessment
 */
export interface FirewallPolicyAssessment {
  /**
   * Output only. If the processing of a policy config fails, an error will be
   * populated and the firewall_policy will be left empty.
   *
   * @generated from protobuf field: google.rpc.Status error = 5;
   */
  error?: Status;
  /**
   * Output only. The policy that matched the request. If more than one policy
   * may match, this is the first match. If no policy matches the incoming
   * request, the policy field will be left empty.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policy = 8;
   */
  firewallPolicy?: FirewallPolicy;
}
/**
 * An individual action. Each action represents what to do if a policy
 * matches.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction
 */
export interface FirewallAction {
  /**
   * @generated from protobuf oneof: firewall_action_oneof
   */
  firewallActionOneof:
    | {
        oneofKind: 'allow';
        /**
         * The user request did not match any policy and should be allowed
         * access to the requested resource.
         *
         * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FirewallAction.AllowAction allow = 1;
         */
        allow: FirewallAction_AllowAction;
      }
    | {
        oneofKind: 'block';
        /**
         * This action will deny access to a given page. The user will get an HTTP
         * error code.
         *
         * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FirewallAction.BlockAction block = 2;
         */
        block: FirewallAction_BlockAction;
      }
    | {
        oneofKind: 'includeRecaptchaScript';
        /**
         * This action will inject reCAPTCHA JavaScript code into the HTML page
         * returned by the site backend.
         *
         * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FirewallAction.IncludeRecaptchaScriptAction include_recaptcha_script = 6;
         */
        includeRecaptchaScript: FirewallAction_IncludeRecaptchaScriptAction;
      }
    | {
        oneofKind: 'redirect';
        /**
         * This action will redirect the request to a ReCaptcha interstitial to
         * attach a token.
         *
         * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FirewallAction.RedirectAction redirect = 5;
         */
        redirect: FirewallAction_RedirectAction;
      }
    | {
        oneofKind: 'substitute';
        /**
         * This action will transparently serve a different page to an offending
         * user.
         *
         * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FirewallAction.SubstituteAction substitute = 3;
         */
        substitute: FirewallAction_SubstituteAction;
      }
    | {
        oneofKind: 'setHeader';
        /**
         * This action will set a custom header but allow the request to continue
         * to the customer backend.
         *
         * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.FirewallAction.SetHeaderAction set_header = 4;
         */
        setHeader: FirewallAction_SetHeaderAction;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * An allow action continues processing a request unimpeded.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.AllowAction
 */
export interface FirewallAction_AllowAction {}
/**
 * A block action serves an HTTP error code a prevents the request from
 * hitting the backend.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.BlockAction
 */
export interface FirewallAction_BlockAction {}
/**
 * An include reCAPTCHA script action involves injecting reCAPTCHA JavaScript
 * code into the HTML returned by the site backend. This reCAPTCHA
 * script is tasked with collecting user signals on the requested web page,
 * issuing tokens as a cookie within the site domain, and enabling their
 * utilization in subsequent page requests.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.IncludeRecaptchaScriptAction
 */
export interface FirewallAction_IncludeRecaptchaScriptAction {}
/**
 * A redirect action returns a 307 (temporary redirect) response, pointing
 * the user to a ReCaptcha interstitial page to attach a token.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.RedirectAction
 */
export interface FirewallAction_RedirectAction {}
/**
 * A substitute action transparently serves a different page than the one
 * requested.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.SubstituteAction
 */
export interface FirewallAction_SubstituteAction {
  /**
   * Optional. The address to redirect to. The target is a relative path in
   * the current host. Example: "/blog/404.html".
   *
   * @generated from protobuf field: string path = 1;
   */
  path: string;
}
/**
 * A set header action sets a header and forwards the request to the
 * backend. This can be used to trigger custom protection implemented on the
 * backend.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.SetHeaderAction
 */
export interface FirewallAction_SetHeaderAction {
  /**
   * Optional. The header key to set in the request to the backend server.
   *
   * @generated from protobuf field: string key = 1;
   */
  key: string;
  /**
   * Optional. The header value to set in the request to the backend server.
   *
   * @generated from protobuf field: string value = 2;
   */
  value: string;
}
/**
 * A FirewallPolicy represents a single matching pattern and resulting actions
 * to take.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.FirewallPolicy
 */
export interface FirewallPolicy {
  /**
   * Identifier. The resource name for the FirewallPolicy in the format
   * `projects/{project}/firewallpolicies/{firewallpolicy}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * Optional. A description of what this policy aims to achieve, for
   * convenience purposes. The description can at most include 256 UTF-8
   * characters.
   *
   * @generated from protobuf field: string description = 2;
   */
  description: string;
  /**
   * Optional. The path for which this policy applies, specified as a glob
   * pattern. For more information on glob, see the [manual
   * page](https://man7.org/linux/man-pages/man7/glob.7.html).
   * A path has a max length of 200 characters.
   *
   * @generated from protobuf field: string path = 4;
   */
  path: string;
  /**
   * Optional. A CEL (Common Expression Language) conditional expression that
   * specifies if this policy applies to an incoming user request. If this
   * condition evaluates to true and the requested path matched the path
   * pattern, the associated actions should be executed by the caller. The
   * condition string is checked for CEL syntax correctness on creation. For
   * more information, see the [CEL spec](https://github.com/google/cel-spec)
   * and its [language
   * definition](https://github.com/google/cel-spec/blob/master/doc/langdef.md).
   * A condition has a max length of 500 characters.
   *
   * @generated from protobuf field: string condition = 5;
   */
  condition: string;
  /**
   * Optional. The actions that the caller should take regarding user access.
   * There should be at most one terminal action. A terminal action is any
   * action that forces a response, such as `AllowAction`,
   * `BlockAction` or `SubstituteAction`.
   * Zero or more non-terminal actions such as `SetHeader` might be
   * specified. A single policy can contain up to 16 actions.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.FirewallAction actions = 6;
   */
  actions: FirewallAction[];
}
/**
 * The request message to list memberships in a related account group.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsRequest
 */
export interface ListRelatedAccountGroupMembershipsRequest {
  /**
   * Required. The resource name for the related account group in the format
   * `projects/{project}/relatedaccountgroups/{relatedaccountgroup}`.
   *
   * @generated from protobuf field: string parent = 1;
   */
  parent: string;
  /**
   * Optional. The maximum number of accounts to return. The service might
   * return fewer than this value. If unspecified, at most 50 accounts are
   * returned. The maximum value is 1000; values above 1000 are coerced to 1000.
   *
   * @generated from protobuf field: int32 page_size = 2;
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous
   * `ListRelatedAccountGroupMemberships` call.
   *
   * When paginating, all other parameters provided to
   * `ListRelatedAccountGroupMemberships` must match the call that provided the
   * page token.
   *
   * @generated from protobuf field: string page_token = 3;
   */
  pageToken: string;
}
/**
 * The response to a `ListRelatedAccountGroupMemberships` call.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsResponse
 */
export interface ListRelatedAccountGroupMembershipsResponse {
  /**
   * The memberships listed by the query.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership related_account_group_memberships = 1;
   */
  relatedAccountGroupMemberships: RelatedAccountGroupMembership[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from protobuf field: string next_page_token = 2;
   */
  nextPageToken: string;
}
/**
 * The request message to list related account groups.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsRequest
 */
export interface ListRelatedAccountGroupsRequest {
  /**
   * Required. The name of the project to list related account groups from, in
   * the format `projects/{project}`.
   *
   * @generated from protobuf field: string parent = 1;
   */
  parent: string;
  /**
   * Optional. The maximum number of groups to return. The service might return
   * fewer than this value. If unspecified, at most 50 groups are returned. The
   * maximum value is 1000; values above 1000 are coerced to 1000.
   *
   * @generated from protobuf field: int32 page_size = 2;
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListRelatedAccountGroups`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListRelatedAccountGroups` must match the call that provided the page
   * token.
   *
   * @generated from protobuf field: string page_token = 3;
   */
  pageToken: string;
}
/**
 * The response to a `ListRelatedAccountGroups` call.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsResponse
 */
export interface ListRelatedAccountGroupsResponse {
  /**
   * The groups of related accounts listed by the query.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.RelatedAccountGroup related_account_groups = 1;
   */
  relatedAccountGroups: RelatedAccountGroup[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from protobuf field: string next_page_token = 2;
   */
  nextPageToken: string;
}
/**
 * The request message to search related account group memberships.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsRequest
 */
export interface SearchRelatedAccountGroupMembershipsRequest {
  /**
   * Required. The name of the project to search related account group
   * memberships from. Specify the project name in the following format:
   * `projects/{project}`.
   *
   * @generated from protobuf field: string project = 1;
   */
  project: string;
  /**
   * Optional. The unique stable account identifier used to search connections.
   * The identifier should correspond to an `account_id` provided in a previous
   * `CreateAssessment` or `AnnotateAssessment` call. Either hashed_account_id
   * or account_id must be set, but not both.
   *
   * @generated from protobuf field: string account_id = 5;
   */
  accountId: string;
  /**
   * Optional. Deprecated: use `account_id` instead.
   * The unique stable hashed account identifier used to search connections. The
   * identifier should correspond to a `hashed_account_id` provided in a
   * previous `CreateAssessment` or `AnnotateAssessment` call. Either
   * hashed_account_id or account_id must be set, but not both.
   *
   * @generated from protobuf field: bytes hashed_account_id = 2;
   */
  hashedAccountId: Uint8Array;
  /**
   * Optional. The maximum number of groups to return. The service might return
   * fewer than this value. If unspecified, at most 50 groups are returned. The
   * maximum value is 1000; values above 1000 are coerced to 1000.
   *
   * @generated from protobuf field: int32 page_size = 3;
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous
   * `SearchRelatedAccountGroupMemberships` call. Provide this to retrieve the
   * subsequent page.
   *
   * When paginating, all other parameters provided to
   * `SearchRelatedAccountGroupMemberships` must match the call that provided
   * the page token.
   *
   * @generated from protobuf field: string page_token = 4;
   */
  pageToken: string;
}
/**
 * The response to a `SearchRelatedAccountGroupMemberships` call.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsResponse
 */
export interface SearchRelatedAccountGroupMembershipsResponse {
  /**
   * The queried memberships.
   *
   * @generated from protobuf field: repeated google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership related_account_group_memberships = 1;
   */
  relatedAccountGroupMemberships: RelatedAccountGroupMembership[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from protobuf field: string next_page_token = 2;
   */
  nextPageToken: string;
}
/**
 * The AddIpOverride request message.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.AddIpOverrideRequest
 */
export interface AddIpOverrideRequest {
  /**
   * Required. The name of the key to which the IP override is added, in the
   * format `projects/{project}/keys/{key}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * Required. IP override added to the key.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.IpOverrideData ip_override_data = 2;
   */
  ipOverrideData?: IpOverrideData;
}
/**
 * Response for AddIpOverride.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.AddIpOverrideResponse
 */
export interface AddIpOverrideResponse {}
/**
 * A membership in a group of related accounts.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership
 */
export interface RelatedAccountGroupMembership {
  /**
   * Required. Identifier. The resource name for this membership in the format
   * `projects/{project}/relatedaccountgroups/{relatedaccountgroup}/memberships/{membership}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
  /**
   * The unique stable account identifier of the member. The identifier
   * corresponds to an `account_id` provided in a previous `CreateAssessment` or
   * `AnnotateAssessment` call.
   *
   * @generated from protobuf field: string account_id = 4;
   */
  accountId: string;
  /**
   * Deprecated: use `account_id` instead.
   * The unique stable hashed account identifier of the member. The identifier
   * corresponds to a `hashed_account_id` provided in a previous
   * `CreateAssessment` or `AnnotateAssessment` call.
   *
   * @deprecated
   * @generated from protobuf field: bytes hashed_account_id = 2 [deprecated = true];
   */
  hashedAccountId: Uint8Array;
}
/**
 * A group of related accounts.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.RelatedAccountGroup
 */
export interface RelatedAccountGroup {
  /**
   * Required. Identifier. The resource name for the related account group in
   * the format
   * `projects/{project}/relatedaccountgroups/{related_account_group}`.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string;
}
/**
 * Settings specific to keys that can be used for WAF (Web Application
 * Firewall).
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.WafSettings
 */
export interface WafSettings {
  /**
   * Required. The WAF service that uses this key.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.WafSettings.WafService waf_service = 1;
   */
  wafService: WafSettings_WafService;
  /**
   * Required. The WAF feature for which this key is enabled.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.WafSettings.WafFeature waf_feature = 2;
   */
  wafFeature: WafSettings_WafFeature;
}
/**
 * Supported WAF features. For more information, see
 * https://cloud.google.com/recaptcha/docs/usecase#comparison_of_features.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.WafSettings.WafFeature
 */
export enum WafSettings_WafFeature {
  /**
   * Undefined feature.
   *
   * @generated from protobuf enum value: WAF_FEATURE_UNSPECIFIED = 0;
   */
  WAF_FEATURE_UNSPECIFIED = 0,
  /**
   * Redirects suspicious traffic to reCAPTCHA.
   *
   * @generated from protobuf enum value: CHALLENGE_PAGE = 1;
   */
  CHALLENGE_PAGE = 1,
  /**
   * Use reCAPTCHA session-tokens to protect the whole user session on the
   * site's domain.
   *
   * @generated from protobuf enum value: SESSION_TOKEN = 2;
   */
  SESSION_TOKEN = 2,
  /**
   * Use reCAPTCHA action-tokens to protect user actions.
   *
   * @generated from protobuf enum value: ACTION_TOKEN = 3;
   */
  ACTION_TOKEN = 3,
  /**
   * Use reCAPTCHA WAF express protection to protect any content other than
   * web pages, like APIs and IoT devices.
   *
   * @generated from protobuf enum value: EXPRESS = 5;
   */
  EXPRESS = 5,
}
/**
 * Web Application Firewalls supported by reCAPTCHA Enterprise.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.WafSettings.WafService
 */
export enum WafSettings_WafService {
  /**
   * Undefined WAF
   *
   * @generated from protobuf enum value: WAF_SERVICE_UNSPECIFIED = 0;
   */
  WAF_SERVICE_UNSPECIFIED = 0,
  /**
   * Cloud Armor
   *
   * @generated from protobuf enum value: CA = 1;
   */
  CA = 1,
  /**
   * Fastly
   *
   * @generated from protobuf enum value: FASTLY = 3;
   */
  FASTLY = 3,
  /**
   * Cloudflare
   *
   * @generated from protobuf enum value: CLOUDFLARE = 4;
   */
  CLOUDFLARE = 4,
}
/**
 * The environment creating the assessment. This describes your environment
 * (the system invoking CreateAssessment), NOT the environment of your user.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.AssessmentEnvironment
 */
export interface AssessmentEnvironment {
  /**
   * Optional. Identifies the client module initiating the CreateAssessment
   * request. This can be the link to the client module's project. Examples
   * include:
   * - "github.com/GoogleCloudPlatform/recaptcha-enterprise-google-tag-manager"
   * - "cloud.google.com/recaptcha/docs/implement-waf-akamai"
   * - "cloud.google.com/recaptcha/docs/implement-waf-cloudflare"
   * - "wordpress.org/plugins/recaptcha-something"
   *
   * @generated from protobuf field: string client = 1;
   */
  client: string;
  /**
   * Optional. The version of the client module. For example, "1.0.0".
   *
   * @generated from protobuf field: string version = 2;
   */
  version: string;
}
/**
 * Information about the IP or IP range override.
 *
 * @generated from protobuf message google.cloud.recaptchaenterprise.v1.IpOverrideData
 */
export interface IpOverrideData {
  /**
   * Required. The IP address to override (can be IPv4, IPv6 or CIDR).
   * The IP override must be a valid IPv4 or IPv6 address, or a CIDR range.
   * The IP override must be a public IP address.
   * Example of IPv4: 168.192.5.6
   * Example of IPv6: 2001:0000:130F:0000:0000:09C0:876A:130B
   * Example of IPv4 with CIDR: 168.192.5.0/24
   * Example of IPv6 with CIDR: 2001:0DB8:1234::/48
   *
   * @generated from protobuf field: string ip = 1;
   */
  ip: string;
  /**
   * Required. Describes the type of IP override.
   *
   * @generated from protobuf field: google.cloud.recaptchaenterprise.v1.IpOverrideData.OverrideType override_type = 3;
   */
  overrideType: IpOverrideData_OverrideType;
}
/**
 * Enum that represents the type of IP override.
 *
 * @generated from protobuf enum google.cloud.recaptchaenterprise.v1.IpOverrideData.OverrideType
 */
export enum IpOverrideData_OverrideType {
  /**
   * Default override type that indicates this enum hasn't been specified.
   *
   * @generated from protobuf enum value: OVERRIDE_TYPE_UNSPECIFIED = 0;
   */
  OVERRIDE_TYPE_UNSPECIFIED = 0,
  /**
   * Allowlist the IP address; i.e. give a `risk_analysis.score` of 0.9 for
   * all valid assessments.
   *
   * @generated from protobuf enum value: ALLOW = 1;
   */
  ALLOW = 1,
}
// @generated message type with reflection information, may provide speed optimized methods
class CreateAssessmentRequest$Type extends MessageType<CreateAssessmentRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.CreateAssessmentRequest', [
      {no: 1, name: 'parent', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'assessment', kind: 'message', T: () => Assessment},
    ]);
  }
  create(
    value?: PartialMessage<CreateAssessmentRequest>,
  ): CreateAssessmentRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.parent = '';
    if (value !== undefined)
      reflectionMergePartial<CreateAssessmentRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CreateAssessmentRequest,
  ): CreateAssessmentRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string parent */ 1:
          message.parent = reader.string();
          break;
        case /* google.cloud.recaptchaenterprise.v1.Assessment assessment */ 2:
          message.assessment = Assessment.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.assessment,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CreateAssessmentRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string parent = 1; */
    if (message.parent !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.parent);
    /* google.cloud.recaptchaenterprise.v1.Assessment assessment = 2; */
    if (message.assessment)
      Assessment.internalBinaryWrite(
        message.assessment,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.CreateAssessmentRequest
 */
export const CreateAssessmentRequest = new CreateAssessmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionEvent$Type extends MessageType<TransactionEvent> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.TransactionEvent', [
      {
        no: 1,
        name: 'event_type',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.TransactionEvent.TransactionEventType',
          TransactionEvent_TransactionEventType,
        ],
      },
      {no: 2, name: 'reason', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 3, name: 'value', kind: 'scalar', T: 1 /*ScalarType.DOUBLE*/},
      {no: 4, name: 'event_time', kind: 'message', T: () => Timestamp},
    ]);
  }
  create(value?: PartialMessage<TransactionEvent>): TransactionEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.eventType = 0;
    message.reason = '';
    message.value = 0;
    if (value !== undefined)
      reflectionMergePartial<TransactionEvent>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TransactionEvent,
  ): TransactionEvent {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.cloud.recaptchaenterprise.v1.TransactionEvent.TransactionEventType event_type */ 1:
          message.eventType = reader.int32();
          break;
        case /* string reason */ 2:
          message.reason = reader.string();
          break;
        case /* double value */ 3:
          message.value = reader.double();
          break;
        case /* google.protobuf.Timestamp event_time */ 4:
          message.eventTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.eventTime,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TransactionEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.cloud.recaptchaenterprise.v1.TransactionEvent.TransactionEventType event_type = 1; */
    if (message.eventType !== 0)
      writer.tag(1, WireType.Varint).int32(message.eventType);
    /* string reason = 2; */
    if (message.reason !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.reason);
    /* double value = 3; */
    if (message.value !== 0)
      writer.tag(3, WireType.Bit64).double(message.value);
    /* google.protobuf.Timestamp event_time = 4; */
    if (message.eventTime)
      Timestamp.internalBinaryWrite(
        message.eventTime,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.TransactionEvent
 */
export const TransactionEvent = new TransactionEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnnotateAssessmentRequest$Type extends MessageType<AnnotateAssessmentRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 2,
        name: 'annotation',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Annotation',
          AnnotateAssessmentRequest_Annotation,
        ],
      },
      {
        no: 3,
        name: 'reasons',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => [
          'google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Reason',
          AnnotateAssessmentRequest_Reason,
        ],
      },
      {no: 7, name: 'account_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 4,
        name: 'hashed_account_id',
        kind: 'scalar',
        T: 12 /*ScalarType.BYTES*/,
      },
      {
        no: 5,
        name: 'transaction_event',
        kind: 'message',
        T: () => TransactionEvent,
      },
    ]);
  }
  create(
    value?: PartialMessage<AnnotateAssessmentRequest>,
  ): AnnotateAssessmentRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    message.annotation = 0;
    message.reasons = [];
    message.accountId = '';
    message.hashedAccountId = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<AnnotateAssessmentRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AnnotateAssessmentRequest,
  ): AnnotateAssessmentRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Annotation annotation */ 2:
          message.annotation = reader.int32();
          break;
        case /* repeated google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Reason reasons */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.reasons.push(reader.int32());
          else message.reasons.push(reader.int32());
          break;
        case /* string account_id */ 7:
          message.accountId = reader.string();
          break;
        case /* bytes hashed_account_id */ 4:
          message.hashedAccountId = reader.bytes();
          break;
        case /* google.cloud.recaptchaenterprise.v1.TransactionEvent transaction_event */ 5:
          message.transactionEvent = TransactionEvent.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.transactionEvent,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AnnotateAssessmentRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Annotation annotation = 2; */
    if (message.annotation !== 0)
      writer.tag(2, WireType.Varint).int32(message.annotation);
    /* repeated google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest.Reason reasons = 3; */
    if (message.reasons.length) {
      writer.tag(3, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.reasons.length; i++)
        writer.int32(message.reasons[i]);
      writer.join();
    }
    /* string account_id = 7; */
    if (message.accountId !== '')
      writer.tag(7, WireType.LengthDelimited).string(message.accountId);
    /* bytes hashed_account_id = 4; */
    if (message.hashedAccountId.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.hashedAccountId);
    /* google.cloud.recaptchaenterprise.v1.TransactionEvent transaction_event = 5; */
    if (message.transactionEvent)
      TransactionEvent.internalBinaryWrite(
        message.transactionEvent,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.AnnotateAssessmentRequest
 */
export const AnnotateAssessmentRequest = new AnnotateAssessmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnnotateAssessmentResponse$Type extends MessageType<AnnotateAssessmentResponse> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.AnnotateAssessmentResponse', []);
  }
  create(
    value?: PartialMessage<AnnotateAssessmentResponse>,
  ): AnnotateAssessmentResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<AnnotateAssessmentResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AnnotateAssessmentResponse,
  ): AnnotateAssessmentResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: AnnotateAssessmentResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.AnnotateAssessmentResponse
 */
export const AnnotateAssessmentResponse = new AnnotateAssessmentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointVerificationInfo$Type extends MessageType<EndpointVerificationInfo> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo', [
      {
        no: 1,
        name: 'email_address',
        kind: 'scalar',
        oneof: 'endpoint',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: 'phone_number',
        kind: 'scalar',
        oneof: 'endpoint',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: 'request_token',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: 'last_verification_time',
        kind: 'message',
        T: () => Timestamp,
      },
    ]);
  }
  create(
    value?: PartialMessage<EndpointVerificationInfo>,
  ): EndpointVerificationInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.endpoint = {oneofKind: undefined};
    message.requestToken = '';
    if (value !== undefined)
      reflectionMergePartial<EndpointVerificationInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EndpointVerificationInfo,
  ): EndpointVerificationInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string email_address */ 1:
          message.endpoint = {
            oneofKind: 'emailAddress',
            emailAddress: reader.string(),
          };
          break;
        case /* string phone_number */ 2:
          message.endpoint = {
            oneofKind: 'phoneNumber',
            phoneNumber: reader.string(),
          };
          break;
        case /* string request_token */ 3:
          message.requestToken = reader.string();
          break;
        case /* google.protobuf.Timestamp last_verification_time */ 4:
          message.lastVerificationTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.lastVerificationTime,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: EndpointVerificationInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string email_address = 1; */
    if (message.endpoint.oneofKind === 'emailAddress')
      writer
        .tag(1, WireType.LengthDelimited)
        .string(message.endpoint.emailAddress);
    /* string phone_number = 2; */
    if (message.endpoint.oneofKind === 'phoneNumber')
      writer
        .tag(2, WireType.LengthDelimited)
        .string(message.endpoint.phoneNumber);
    /* string request_token = 3; */
    if (message.requestToken !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.requestToken);
    /* google.protobuf.Timestamp last_verification_time = 4; */
    if (message.lastVerificationTime)
      Timestamp.internalBinaryWrite(
        message.lastVerificationTime,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo
 */
export const EndpointVerificationInfo = new EndpointVerificationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountVerificationInfo$Type extends MessageType<AccountVerificationInfo> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.AccountVerificationInfo', [
      {
        no: 1,
        name: 'endpoints',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => EndpointVerificationInfo,
      },
      {
        no: 3,
        name: 'language_code',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 7,
        name: 'latest_verification_result',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.AccountVerificationInfo.Result',
          AccountVerificationInfo_Result,
        ],
      },
      {no: 2, name: 'username', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(
    value?: PartialMessage<AccountVerificationInfo>,
  ): AccountVerificationInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.endpoints = [];
    message.languageCode = '';
    message.latestVerificationResult = 0;
    message.username = '';
    if (value !== undefined)
      reflectionMergePartial<AccountVerificationInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AccountVerificationInfo,
  ): AccountVerificationInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo endpoints */ 1:
          message.endpoints.push(
            EndpointVerificationInfo.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* string language_code */ 3:
          message.languageCode = reader.string();
          break;
        case /* google.cloud.recaptchaenterprise.v1.AccountVerificationInfo.Result latest_verification_result */ 7:
          message.latestVerificationResult = reader.int32();
          break;
        case /* string username = 2 [deprecated = true];*/ 2:
          message.username = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AccountVerificationInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated google.cloud.recaptchaenterprise.v1.EndpointVerificationInfo endpoints = 1; */
    for (let i = 0; i < message.endpoints.length; i++)
      EndpointVerificationInfo.internalBinaryWrite(
        message.endpoints[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string language_code = 3; */
    if (message.languageCode !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.languageCode);
    /* google.cloud.recaptchaenterprise.v1.AccountVerificationInfo.Result latest_verification_result = 7; */
    if (message.latestVerificationResult !== 0)
      writer.tag(7, WireType.Varint).int32(message.latestVerificationResult);
    /* string username = 2 [deprecated = true]; */
    if (message.username !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.username);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.AccountVerificationInfo
 */
export const AccountVerificationInfo = new AccountVerificationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrivatePasswordLeakVerification$Type extends MessageType<PrivatePasswordLeakVerification> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.PrivatePasswordLeakVerification',
      [
        {
          no: 1,
          name: 'lookup_hash_prefix',
          kind: 'scalar',
          T: 12 /*ScalarType.BYTES*/,
        },
        {
          no: 2,
          name: 'encrypted_user_credentials_hash',
          kind: 'scalar',
          T: 12 /*ScalarType.BYTES*/,
        },
        {
          no: 3,
          name: 'encrypted_leak_match_prefixes',
          kind: 'scalar',
          repeat: 2 /*RepeatType.UNPACKED*/,
          T: 12 /*ScalarType.BYTES*/,
        },
        {
          no: 4,
          name: 'reencrypted_user_credentials_hash',
          kind: 'scalar',
          T: 12 /*ScalarType.BYTES*/,
        },
      ],
    );
  }
  create(
    value?: PartialMessage<PrivatePasswordLeakVerification>,
  ): PrivatePasswordLeakVerification {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.lookupHashPrefix = new Uint8Array(0);
    message.encryptedUserCredentialsHash = new Uint8Array(0);
    message.encryptedLeakMatchPrefixes = [];
    message.reencryptedUserCredentialsHash = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<PrivatePasswordLeakVerification>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PrivatePasswordLeakVerification,
  ): PrivatePasswordLeakVerification {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes lookup_hash_prefix */ 1:
          message.lookupHashPrefix = reader.bytes();
          break;
        case /* bytes encrypted_user_credentials_hash */ 2:
          message.encryptedUserCredentialsHash = reader.bytes();
          break;
        case /* repeated bytes encrypted_leak_match_prefixes */ 3:
          message.encryptedLeakMatchPrefixes.push(reader.bytes());
          break;
        case /* bytes reencrypted_user_credentials_hash */ 4:
          message.reencryptedUserCredentialsHash = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PrivatePasswordLeakVerification,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes lookup_hash_prefix = 1; */
    if (message.lookupHashPrefix.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.lookupHashPrefix);
    /* bytes encrypted_user_credentials_hash = 2; */
    if (message.encryptedUserCredentialsHash.length)
      writer
        .tag(2, WireType.LengthDelimited)
        .bytes(message.encryptedUserCredentialsHash);
    /* repeated bytes encrypted_leak_match_prefixes = 3; */
    for (let i = 0; i < message.encryptedLeakMatchPrefixes.length; i++)
      writer
        .tag(3, WireType.LengthDelimited)
        .bytes(message.encryptedLeakMatchPrefixes[i]);
    /* bytes reencrypted_user_credentials_hash = 4; */
    if (message.reencryptedUserCredentialsHash.length)
      writer
        .tag(4, WireType.LengthDelimited)
        .bytes(message.reencryptedUserCredentialsHash);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.PrivatePasswordLeakVerification
 */
export const PrivatePasswordLeakVerification =
  new PrivatePasswordLeakVerification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Assessment$Type extends MessageType<Assessment> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.Assessment', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'event', kind: 'message', T: () => Event},
      {no: 3, name: 'risk_analysis', kind: 'message', T: () => RiskAnalysis},
      {
        no: 4,
        name: 'token_properties',
        kind: 'message',
        T: () => TokenProperties,
      },
      {
        no: 5,
        name: 'account_verification',
        kind: 'message',
        T: () => AccountVerificationInfo,
      },
      {
        no: 6,
        name: 'account_defender_assessment',
        kind: 'message',
        T: () => AccountDefenderAssessment,
      },
      {
        no: 8,
        name: 'private_password_leak_verification',
        kind: 'message',
        T: () => PrivatePasswordLeakVerification,
      },
      {
        no: 10,
        name: 'firewall_policy_assessment',
        kind: 'message',
        T: () => FirewallPolicyAssessment,
      },
      {
        no: 11,
        name: 'fraud_prevention_assessment',
        kind: 'message',
        T: () => FraudPreventionAssessment,
      },
      {no: 13, name: 'fraud_signals', kind: 'message', T: () => FraudSignals},
      {
        no: 12,
        name: 'phone_fraud_assessment',
        kind: 'message',
        T: () => PhoneFraudAssessment,
      },
      {
        no: 14,
        name: 'assessment_environment',
        kind: 'message',
        T: () => AssessmentEnvironment,
      },
    ]);
  }
  create(value?: PartialMessage<Assessment>): Assessment {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    if (value !== undefined)
      reflectionMergePartial<Assessment>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Assessment,
  ): Assessment {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* google.cloud.recaptchaenterprise.v1.Event event */ 2:
          message.event = Event.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.event,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.RiskAnalysis risk_analysis */ 3:
          message.riskAnalysis = RiskAnalysis.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.riskAnalysis,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.TokenProperties token_properties */ 4:
          message.tokenProperties = TokenProperties.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.tokenProperties,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.AccountVerificationInfo account_verification */ 5:
          message.accountVerification =
            AccountVerificationInfo.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.accountVerification,
            );
          break;
        case /* google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment account_defender_assessment */ 6:
          message.accountDefenderAssessment =
            AccountDefenderAssessment.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.accountDefenderAssessment,
            );
          break;
        case /* google.cloud.recaptchaenterprise.v1.PrivatePasswordLeakVerification private_password_leak_verification */ 8:
          message.privatePasswordLeakVerification =
            PrivatePasswordLeakVerification.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.privatePasswordLeakVerification,
            );
          break;
        case /* google.cloud.recaptchaenterprise.v1.FirewallPolicyAssessment firewall_policy_assessment */ 10:
          message.firewallPolicyAssessment =
            FirewallPolicyAssessment.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.firewallPolicyAssessment,
            );
          break;
        case /* google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment fraud_prevention_assessment */ 11:
          message.fraudPreventionAssessment =
            FraudPreventionAssessment.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.fraudPreventionAssessment,
            );
          break;
        case /* google.cloud.recaptchaenterprise.v1.FraudSignals fraud_signals */ 13:
          message.fraudSignals = FraudSignals.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.fraudSignals,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.PhoneFraudAssessment phone_fraud_assessment */ 12:
          message.phoneFraudAssessment =
            PhoneFraudAssessment.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.phoneFraudAssessment,
            );
          break;
        case /* google.cloud.recaptchaenterprise.v1.AssessmentEnvironment assessment_environment */ 14:
          message.assessmentEnvironment =
            AssessmentEnvironment.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.assessmentEnvironment,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Assessment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* google.cloud.recaptchaenterprise.v1.Event event = 2; */
    if (message.event)
      Event.internalBinaryWrite(
        message.event,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.RiskAnalysis risk_analysis = 3; */
    if (message.riskAnalysis)
      RiskAnalysis.internalBinaryWrite(
        message.riskAnalysis,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.TokenProperties token_properties = 4; */
    if (message.tokenProperties)
      TokenProperties.internalBinaryWrite(
        message.tokenProperties,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.AccountVerificationInfo account_verification = 5; */
    if (message.accountVerification)
      AccountVerificationInfo.internalBinaryWrite(
        message.accountVerification,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment account_defender_assessment = 6; */
    if (message.accountDefenderAssessment)
      AccountDefenderAssessment.internalBinaryWrite(
        message.accountDefenderAssessment,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.PrivatePasswordLeakVerification private_password_leak_verification = 8; */
    if (message.privatePasswordLeakVerification)
      PrivatePasswordLeakVerification.internalBinaryWrite(
        message.privatePasswordLeakVerification,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FirewallPolicyAssessment firewall_policy_assessment = 10; */
    if (message.firewallPolicyAssessment)
      FirewallPolicyAssessment.internalBinaryWrite(
        message.firewallPolicyAssessment,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment fraud_prevention_assessment = 11; */
    if (message.fraudPreventionAssessment)
      FraudPreventionAssessment.internalBinaryWrite(
        message.fraudPreventionAssessment,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FraudSignals fraud_signals = 13; */
    if (message.fraudSignals)
      FraudSignals.internalBinaryWrite(
        message.fraudSignals,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.PhoneFraudAssessment phone_fraud_assessment = 12; */
    if (message.phoneFraudAssessment)
      PhoneFraudAssessment.internalBinaryWrite(
        message.phoneFraudAssessment,
        writer.tag(12, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.AssessmentEnvironment assessment_environment = 14; */
    if (message.assessmentEnvironment)
      AssessmentEnvironment.internalBinaryWrite(
        message.assessmentEnvironment,
        writer.tag(14, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.Assessment
 */
export const Assessment = new Assessment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.Event', [
      {no: 1, name: 'token', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'site_key', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 3, name: 'user_agent', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 4,
        name: 'user_ip_address',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: 'expected_action',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: 'hashed_account_id',
        kind: 'scalar',
        T: 12 /*ScalarType.BYTES*/,
      },
      {no: 14, name: 'express', kind: 'scalar', T: 8 /*ScalarType.BOOL*/},
      {
        no: 8,
        name: 'requested_uri',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 9,
        name: 'waf_token_assessment',
        kind: 'scalar',
        T: 8 /*ScalarType.BOOL*/,
      },
      {no: 10, name: 'ja3', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 11,
        name: 'headers',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 12,
        name: 'firewall_policy_evaluation',
        kind: 'scalar',
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 13,
        name: 'transaction_data',
        kind: 'message',
        T: () => TransactionData,
      },
      {no: 15, name: 'user_info', kind: 'message', T: () => UserInfo},
      {
        no: 17,
        name: 'fraud_prevention',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.Event.FraudPrevention',
          Event_FraudPrevention,
        ],
      },
    ]);
  }
  create(value?: PartialMessage<Event>): Event {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.token = '';
    message.siteKey = '';
    message.userAgent = '';
    message.userIpAddress = '';
    message.expectedAction = '';
    message.hashedAccountId = new Uint8Array(0);
    message.express = false;
    message.requestedUri = '';
    message.wafTokenAssessment = false;
    message.ja3 = '';
    message.headers = [];
    message.firewallPolicyEvaluation = false;
    message.fraudPrevention = 0;
    if (value !== undefined)
      reflectionMergePartial<Event>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Event,
  ): Event {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string token */ 1:
          message.token = reader.string();
          break;
        case /* string site_key */ 2:
          message.siteKey = reader.string();
          break;
        case /* string user_agent */ 3:
          message.userAgent = reader.string();
          break;
        case /* string user_ip_address */ 4:
          message.userIpAddress = reader.string();
          break;
        case /* string expected_action */ 5:
          message.expectedAction = reader.string();
          break;
        case /* bytes hashed_account_id */ 6:
          message.hashedAccountId = reader.bytes();
          break;
        case /* bool express */ 14:
          message.express = reader.bool();
          break;
        case /* string requested_uri */ 8:
          message.requestedUri = reader.string();
          break;
        case /* bool waf_token_assessment */ 9:
          message.wafTokenAssessment = reader.bool();
          break;
        case /* string ja3 */ 10:
          message.ja3 = reader.string();
          break;
        case /* repeated string headers */ 11:
          message.headers.push(reader.string());
          break;
        case /* bool firewall_policy_evaluation */ 12:
          message.firewallPolicyEvaluation = reader.bool();
          break;
        case /* google.cloud.recaptchaenterprise.v1.TransactionData transaction_data */ 13:
          message.transactionData = TransactionData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.transactionData,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.UserInfo user_info */ 15:
          message.userInfo = UserInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.userInfo,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.Event.FraudPrevention fraud_prevention */ 17:
          message.fraudPrevention = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Event,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string token = 1; */
    if (message.token !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.token);
    /* string site_key = 2; */
    if (message.siteKey !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.siteKey);
    /* string user_agent = 3; */
    if (message.userAgent !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.userAgent);
    /* string user_ip_address = 4; */
    if (message.userIpAddress !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.userIpAddress);
    /* string expected_action = 5; */
    if (message.expectedAction !== '')
      writer.tag(5, WireType.LengthDelimited).string(message.expectedAction);
    /* bytes hashed_account_id = 6; */
    if (message.hashedAccountId.length)
      writer.tag(6, WireType.LengthDelimited).bytes(message.hashedAccountId);
    /* bool express = 14; */
    if (message.express !== false)
      writer.tag(14, WireType.Varint).bool(message.express);
    /* string requested_uri = 8; */
    if (message.requestedUri !== '')
      writer.tag(8, WireType.LengthDelimited).string(message.requestedUri);
    /* bool waf_token_assessment = 9; */
    if (message.wafTokenAssessment !== false)
      writer.tag(9, WireType.Varint).bool(message.wafTokenAssessment);
    /* string ja3 = 10; */
    if (message.ja3 !== '')
      writer.tag(10, WireType.LengthDelimited).string(message.ja3);
    /* repeated string headers = 11; */
    for (let i = 0; i < message.headers.length; i++)
      writer.tag(11, WireType.LengthDelimited).string(message.headers[i]);
    /* bool firewall_policy_evaluation = 12; */
    if (message.firewallPolicyEvaluation !== false)
      writer.tag(12, WireType.Varint).bool(message.firewallPolicyEvaluation);
    /* google.cloud.recaptchaenterprise.v1.TransactionData transaction_data = 13; */
    if (message.transactionData)
      TransactionData.internalBinaryWrite(
        message.transactionData,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.UserInfo user_info = 15; */
    if (message.userInfo)
      UserInfo.internalBinaryWrite(
        message.userInfo,
        writer.tag(15, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.Event.FraudPrevention fraud_prevention = 17; */
    if (message.fraudPrevention !== 0)
      writer.tag(17, WireType.Varint).int32(message.fraudPrevention);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionData$Type extends MessageType<TransactionData> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.TransactionData', [
      {
        no: 11,
        name: 'transaction_id',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 1,
        name: 'payment_method',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {no: 2, name: 'card_bin', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 3,
        name: 'card_last_four',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: 'currency_code',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {no: 5, name: 'value', kind: 'scalar', T: 1 /*ScalarType.DOUBLE*/},
      {
        no: 12,
        name: 'shipping_value',
        kind: 'scalar',
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 6,
        name: 'shipping_address',
        kind: 'message',
        T: () => TransactionData_Address,
      },
      {
        no: 7,
        name: 'billing_address',
        kind: 'message',
        T: () => TransactionData_Address,
      },
      {no: 8, name: 'user', kind: 'message', T: () => TransactionData_User},
      {
        no: 13,
        name: 'merchants',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => TransactionData_User,
      },
      {
        no: 14,
        name: 'items',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => TransactionData_Item,
      },
      {
        no: 10,
        name: 'gateway_info',
        kind: 'message',
        T: () => TransactionData_GatewayInfo,
      },
    ]);
  }
  create(value?: PartialMessage<TransactionData>): TransactionData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.paymentMethod = '';
    message.cardBin = '';
    message.cardLastFour = '';
    message.currencyCode = '';
    message.value = 0;
    message.shippingValue = 0;
    message.merchants = [];
    message.items = [];
    if (value !== undefined)
      reflectionMergePartial<TransactionData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TransactionData,
  ): TransactionData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string transaction_id */ 11:
          message.transactionId = reader.string();
          break;
        case /* string payment_method */ 1:
          message.paymentMethod = reader.string();
          break;
        case /* string card_bin */ 2:
          message.cardBin = reader.string();
          break;
        case /* string card_last_four */ 3:
          message.cardLastFour = reader.string();
          break;
        case /* string currency_code */ 4:
          message.currencyCode = reader.string();
          break;
        case /* double value */ 5:
          message.value = reader.double();
          break;
        case /* double shipping_value */ 12:
          message.shippingValue = reader.double();
          break;
        case /* google.cloud.recaptchaenterprise.v1.TransactionData.Address shipping_address */ 6:
          message.shippingAddress = TransactionData_Address.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.shippingAddress,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.TransactionData.Address billing_address */ 7:
          message.billingAddress = TransactionData_Address.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.billingAddress,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.TransactionData.User user */ 8:
          message.user = TransactionData_User.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.user,
          );
          break;
        case /* repeated google.cloud.recaptchaenterprise.v1.TransactionData.User merchants */ 13:
          message.merchants.push(
            TransactionData_User.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated google.cloud.recaptchaenterprise.v1.TransactionData.Item items */ 14:
          message.items.push(
            TransactionData_Item.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.TransactionData.GatewayInfo gateway_info */ 10:
          message.gatewayInfo = TransactionData_GatewayInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.gatewayInfo,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TransactionData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string transaction_id = 11; */
    if (message.transactionId !== undefined)
      writer.tag(11, WireType.LengthDelimited).string(message.transactionId);
    /* string payment_method = 1; */
    if (message.paymentMethod !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.paymentMethod);
    /* string card_bin = 2; */
    if (message.cardBin !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.cardBin);
    /* string card_last_four = 3; */
    if (message.cardLastFour !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.cardLastFour);
    /* string currency_code = 4; */
    if (message.currencyCode !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.currencyCode);
    /* double value = 5; */
    if (message.value !== 0)
      writer.tag(5, WireType.Bit64).double(message.value);
    /* double shipping_value = 12; */
    if (message.shippingValue !== 0)
      writer.tag(12, WireType.Bit64).double(message.shippingValue);
    /* google.cloud.recaptchaenterprise.v1.TransactionData.Address shipping_address = 6; */
    if (message.shippingAddress)
      TransactionData_Address.internalBinaryWrite(
        message.shippingAddress,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.TransactionData.Address billing_address = 7; */
    if (message.billingAddress)
      TransactionData_Address.internalBinaryWrite(
        message.billingAddress,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.TransactionData.User user = 8; */
    if (message.user)
      TransactionData_User.internalBinaryWrite(
        message.user,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated google.cloud.recaptchaenterprise.v1.TransactionData.User merchants = 13; */
    for (let i = 0; i < message.merchants.length; i++)
      TransactionData_User.internalBinaryWrite(
        message.merchants[i],
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated google.cloud.recaptchaenterprise.v1.TransactionData.Item items = 14; */
    for (let i = 0; i < message.items.length; i++)
      TransactionData_Item.internalBinaryWrite(
        message.items[i],
        writer.tag(14, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.TransactionData.GatewayInfo gateway_info = 10; */
    if (message.gatewayInfo)
      TransactionData_GatewayInfo.internalBinaryWrite(
        message.gatewayInfo,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.TransactionData
 */
export const TransactionData = new TransactionData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionData_Address$Type extends MessageType<TransactionData_Address> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.TransactionData.Address', [
      {no: 1, name: 'recipient', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 2,
        name: 'address',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {no: 3, name: 'locality', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 4,
        name: 'administrative_area',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {no: 5, name: 'region_code', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 6, name: 'postal_code', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(
    value?: PartialMessage<TransactionData_Address>,
  ): TransactionData_Address {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.recipient = '';
    message.address = [];
    message.locality = '';
    message.administrativeArea = '';
    message.regionCode = '';
    message.postalCode = '';
    if (value !== undefined)
      reflectionMergePartial<TransactionData_Address>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TransactionData_Address,
  ): TransactionData_Address {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string recipient */ 1:
          message.recipient = reader.string();
          break;
        case /* repeated string address */ 2:
          message.address.push(reader.string());
          break;
        case /* string locality */ 3:
          message.locality = reader.string();
          break;
        case /* string administrative_area */ 4:
          message.administrativeArea = reader.string();
          break;
        case /* string region_code */ 5:
          message.regionCode = reader.string();
          break;
        case /* string postal_code */ 6:
          message.postalCode = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TransactionData_Address,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string recipient = 1; */
    if (message.recipient !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.recipient);
    /* repeated string address = 2; */
    for (let i = 0; i < message.address.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.address[i]);
    /* string locality = 3; */
    if (message.locality !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.locality);
    /* string administrative_area = 4; */
    if (message.administrativeArea !== '')
      writer
        .tag(4, WireType.LengthDelimited)
        .string(message.administrativeArea);
    /* string region_code = 5; */
    if (message.regionCode !== '')
      writer.tag(5, WireType.LengthDelimited).string(message.regionCode);
    /* string postal_code = 6; */
    if (message.postalCode !== '')
      writer.tag(6, WireType.LengthDelimited).string(message.postalCode);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.TransactionData.Address
 */
export const TransactionData_Address = new TransactionData_Address$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionData_User$Type extends MessageType<TransactionData_User> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.TransactionData.User', [
      {no: 6, name: 'account_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 1,
        name: 'creation_ms',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {no: 2, name: 'email', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 3, name: 'email_verified', kind: 'scalar', T: 8 /*ScalarType.BOOL*/},
      {no: 4, name: 'phone_number', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 5, name: 'phone_verified', kind: 'scalar', T: 8 /*ScalarType.BOOL*/},
    ]);
  }
  create(value?: PartialMessage<TransactionData_User>): TransactionData_User {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.accountId = '';
    message.creationMs = 0n;
    message.email = '';
    message.emailVerified = false;
    message.phoneNumber = '';
    message.phoneVerified = false;
    if (value !== undefined)
      reflectionMergePartial<TransactionData_User>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TransactionData_User,
  ): TransactionData_User {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string account_id */ 6:
          message.accountId = reader.string();
          break;
        case /* int64 creation_ms */ 1:
          message.creationMs = reader.int64().toBigInt();
          break;
        case /* string email */ 2:
          message.email = reader.string();
          break;
        case /* bool email_verified */ 3:
          message.emailVerified = reader.bool();
          break;
        case /* string phone_number */ 4:
          message.phoneNumber = reader.string();
          break;
        case /* bool phone_verified */ 5:
          message.phoneVerified = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TransactionData_User,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string account_id = 6; */
    if (message.accountId !== '')
      writer.tag(6, WireType.LengthDelimited).string(message.accountId);
    /* int64 creation_ms = 1; */
    if (message.creationMs !== 0n)
      writer.tag(1, WireType.Varint).int64(message.creationMs);
    /* string email = 2; */
    if (message.email !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.email);
    /* bool email_verified = 3; */
    if (message.emailVerified !== false)
      writer.tag(3, WireType.Varint).bool(message.emailVerified);
    /* string phone_number = 4; */
    if (message.phoneNumber !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.phoneNumber);
    /* bool phone_verified = 5; */
    if (message.phoneVerified !== false)
      writer.tag(5, WireType.Varint).bool(message.phoneVerified);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.TransactionData.User
 */
export const TransactionData_User = new TransactionData_User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionData_Item$Type extends MessageType<TransactionData_Item> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.TransactionData.Item', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'value', kind: 'scalar', T: 1 /*ScalarType.DOUBLE*/},
      {
        no: 3,
        name: 'quantity',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: 'merchant_account_id',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<TransactionData_Item>): TransactionData_Item {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    message.value = 0;
    message.quantity = 0n;
    message.merchantAccountId = '';
    if (value !== undefined)
      reflectionMergePartial<TransactionData_Item>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TransactionData_Item,
  ): TransactionData_Item {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* double value */ 2:
          message.value = reader.double();
          break;
        case /* int64 quantity */ 3:
          message.quantity = reader.int64().toBigInt();
          break;
        case /* string merchant_account_id */ 4:
          message.merchantAccountId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TransactionData_Item,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* double value = 2; */
    if (message.value !== 0)
      writer.tag(2, WireType.Bit64).double(message.value);
    /* int64 quantity = 3; */
    if (message.quantity !== 0n)
      writer.tag(3, WireType.Varint).int64(message.quantity);
    /* string merchant_account_id = 4; */
    if (message.merchantAccountId !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.merchantAccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.TransactionData.Item
 */
export const TransactionData_Item = new TransactionData_Item$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionData_GatewayInfo$Type extends MessageType<TransactionData_GatewayInfo> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.TransactionData.GatewayInfo', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 2,
        name: 'gateway_response_code',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: 'avs_response_code',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: 'cvv_response_code',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<TransactionData_GatewayInfo>,
  ): TransactionData_GatewayInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    message.gatewayResponseCode = '';
    message.avsResponseCode = '';
    message.cvvResponseCode = '';
    if (value !== undefined)
      reflectionMergePartial<TransactionData_GatewayInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TransactionData_GatewayInfo,
  ): TransactionData_GatewayInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* string gateway_response_code */ 2:
          message.gatewayResponseCode = reader.string();
          break;
        case /* string avs_response_code */ 3:
          message.avsResponseCode = reader.string();
          break;
        case /* string cvv_response_code */ 4:
          message.cvvResponseCode = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TransactionData_GatewayInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* string gateway_response_code = 2; */
    if (message.gatewayResponseCode !== '')
      writer
        .tag(2, WireType.LengthDelimited)
        .string(message.gatewayResponseCode);
    /* string avs_response_code = 3; */
    if (message.avsResponseCode !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.avsResponseCode);
    /* string cvv_response_code = 4; */
    if (message.cvvResponseCode !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.cvvResponseCode);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.TransactionData.GatewayInfo
 */
export const TransactionData_GatewayInfo =
  new TransactionData_GatewayInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserInfo$Type extends MessageType<UserInfo> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.UserInfo', [
      {no: 1, name: 'create_account_time', kind: 'message', T: () => Timestamp},
      {no: 2, name: 'account_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 3,
        name: 'user_ids',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => UserId,
      },
    ]);
  }
  create(value?: PartialMessage<UserInfo>): UserInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.accountId = '';
    message.userIds = [];
    if (value !== undefined)
      reflectionMergePartial<UserInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UserInfo,
  ): UserInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.protobuf.Timestamp create_account_time */ 1:
          message.createAccountTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.createAccountTime,
          );
          break;
        case /* string account_id */ 2:
          message.accountId = reader.string();
          break;
        case /* repeated google.cloud.recaptchaenterprise.v1.UserId user_ids */ 3:
          message.userIds.push(
            UserId.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UserInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.protobuf.Timestamp create_account_time = 1; */
    if (message.createAccountTime)
      Timestamp.internalBinaryWrite(
        message.createAccountTime,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string account_id = 2; */
    if (message.accountId !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.accountId);
    /* repeated google.cloud.recaptchaenterprise.v1.UserId user_ids = 3; */
    for (let i = 0; i < message.userIds.length; i++)
      UserId.internalBinaryWrite(
        message.userIds[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.UserInfo
 */
export const UserInfo = new UserInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserId$Type extends MessageType<UserId> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.UserId', [
      {
        no: 1,
        name: 'email',
        kind: 'scalar',
        oneof: 'idOneof',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: 'phone_number',
        kind: 'scalar',
        oneof: 'idOneof',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: 'username',
        kind: 'scalar',
        oneof: 'idOneof',
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<UserId>): UserId {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.idOneof = {oneofKind: undefined};
    if (value !== undefined)
      reflectionMergePartial<UserId>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UserId,
  ): UserId {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string email */ 1:
          message.idOneof = {
            oneofKind: 'email',
            email: reader.string(),
          };
          break;
        case /* string phone_number */ 2:
          message.idOneof = {
            oneofKind: 'phoneNumber',
            phoneNumber: reader.string(),
          };
          break;
        case /* string username */ 3:
          message.idOneof = {
            oneofKind: 'username',
            username: reader.string(),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UserId,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string email = 1; */
    if (message.idOneof.oneofKind === 'email')
      writer.tag(1, WireType.LengthDelimited).string(message.idOneof.email);
    /* string phone_number = 2; */
    if (message.idOneof.oneofKind === 'phoneNumber')
      writer
        .tag(2, WireType.LengthDelimited)
        .string(message.idOneof.phoneNumber);
    /* string username = 3; */
    if (message.idOneof.oneofKind === 'username')
      writer.tag(3, WireType.LengthDelimited).string(message.idOneof.username);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.UserId
 */
export const UserId = new UserId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RiskAnalysis$Type extends MessageType<RiskAnalysis> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.RiskAnalysis', [
      {no: 1, name: 'score', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/},
      {
        no: 2,
        name: 'reasons',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => [
          'google.cloud.recaptchaenterprise.v1.RiskAnalysis.ClassificationReason',
          RiskAnalysis_ClassificationReason,
        ],
      },
      {
        no: 3,
        name: 'extended_verdict_reasons',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<RiskAnalysis>): RiskAnalysis {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.score = 0;
    message.reasons = [];
    message.extendedVerdictReasons = [];
    if (value !== undefined)
      reflectionMergePartial<RiskAnalysis>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RiskAnalysis,
  ): RiskAnalysis {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* float score */ 1:
          message.score = reader.float();
          break;
        case /* repeated google.cloud.recaptchaenterprise.v1.RiskAnalysis.ClassificationReason reasons */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.reasons.push(reader.int32());
          else message.reasons.push(reader.int32());
          break;
        case /* repeated string extended_verdict_reasons */ 3:
          message.extendedVerdictReasons.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RiskAnalysis,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* float score = 1; */
    if (message.score !== 0) writer.tag(1, WireType.Bit32).float(message.score);
    /* repeated google.cloud.recaptchaenterprise.v1.RiskAnalysis.ClassificationReason reasons = 2; */
    if (message.reasons.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.reasons.length; i++)
        writer.int32(message.reasons[i]);
      writer.join();
    }
    /* repeated string extended_verdict_reasons = 3; */
    for (let i = 0; i < message.extendedVerdictReasons.length; i++)
      writer
        .tag(3, WireType.LengthDelimited)
        .string(message.extendedVerdictReasons[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.RiskAnalysis
 */
export const RiskAnalysis = new RiskAnalysis$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenProperties$Type extends MessageType<TokenProperties> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.TokenProperties', [
      {no: 1, name: 'valid', kind: 'scalar', T: 8 /*ScalarType.BOOL*/},
      {
        no: 2,
        name: 'invalid_reason',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.TokenProperties.InvalidReason',
          TokenProperties_InvalidReason,
        ],
      },
      {no: 3, name: 'create_time', kind: 'message', T: () => Timestamp},
      {no: 4, name: 'hostname', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 8,
        name: 'android_package_name',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 9,
        name: 'ios_bundle_id',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {no: 5, name: 'action', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(value?: PartialMessage<TokenProperties>): TokenProperties {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.valid = false;
    message.invalidReason = 0;
    message.hostname = '';
    message.androidPackageName = '';
    message.iosBundleId = '';
    message.action = '';
    if (value !== undefined)
      reflectionMergePartial<TokenProperties>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TokenProperties,
  ): TokenProperties {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool valid */ 1:
          message.valid = reader.bool();
          break;
        case /* google.cloud.recaptchaenterprise.v1.TokenProperties.InvalidReason invalid_reason */ 2:
          message.invalidReason = reader.int32();
          break;
        case /* google.protobuf.Timestamp create_time */ 3:
          message.createTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.createTime,
          );
          break;
        case /* string hostname */ 4:
          message.hostname = reader.string();
          break;
        case /* string android_package_name */ 8:
          message.androidPackageName = reader.string();
          break;
        case /* string ios_bundle_id */ 9:
          message.iosBundleId = reader.string();
          break;
        case /* string action */ 5:
          message.action = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TokenProperties,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool valid = 1; */
    if (message.valid !== false)
      writer.tag(1, WireType.Varint).bool(message.valid);
    /* google.cloud.recaptchaenterprise.v1.TokenProperties.InvalidReason invalid_reason = 2; */
    if (message.invalidReason !== 0)
      writer.tag(2, WireType.Varint).int32(message.invalidReason);
    /* google.protobuf.Timestamp create_time = 3; */
    if (message.createTime)
      Timestamp.internalBinaryWrite(
        message.createTime,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string hostname = 4; */
    if (message.hostname !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.hostname);
    /* string android_package_name = 8; */
    if (message.androidPackageName !== '')
      writer
        .tag(8, WireType.LengthDelimited)
        .string(message.androidPackageName);
    /* string ios_bundle_id = 9; */
    if (message.iosBundleId !== '')
      writer.tag(9, WireType.LengthDelimited).string(message.iosBundleId);
    /* string action = 5; */
    if (message.action !== '')
      writer.tag(5, WireType.LengthDelimited).string(message.action);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.TokenProperties
 */
export const TokenProperties = new TokenProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FraudPreventionAssessment$Type extends MessageType<FraudPreventionAssessment> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment', [
      {
        no: 1,
        name: 'transaction_risk',
        kind: 'scalar',
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 2,
        name: 'stolen_instrument_verdict',
        kind: 'message',
        T: () => FraudPreventionAssessment_StolenInstrumentVerdict,
      },
      {
        no: 3,
        name: 'card_testing_verdict',
        kind: 'message',
        T: () => FraudPreventionAssessment_CardTestingVerdict,
      },
      {
        no: 4,
        name: 'behavioral_trust_verdict',
        kind: 'message',
        T: () => FraudPreventionAssessment_BehavioralTrustVerdict,
      },
    ]);
  }
  create(
    value?: PartialMessage<FraudPreventionAssessment>,
  ): FraudPreventionAssessment {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.transactionRisk = 0;
    if (value !== undefined)
      reflectionMergePartial<FraudPreventionAssessment>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FraudPreventionAssessment,
  ): FraudPreventionAssessment {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* float transaction_risk */ 1:
          message.transactionRisk = reader.float();
          break;
        case /* google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.StolenInstrumentVerdict stolen_instrument_verdict */ 2:
          message.stolenInstrumentVerdict =
            FraudPreventionAssessment_StolenInstrumentVerdict.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.stolenInstrumentVerdict,
            );
          break;
        case /* google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.CardTestingVerdict card_testing_verdict */ 3:
          message.cardTestingVerdict =
            FraudPreventionAssessment_CardTestingVerdict.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.cardTestingVerdict,
            );
          break;
        case /* google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.BehavioralTrustVerdict behavioral_trust_verdict */ 4:
          message.behavioralTrustVerdict =
            FraudPreventionAssessment_BehavioralTrustVerdict.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.behavioralTrustVerdict,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FraudPreventionAssessment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* float transaction_risk = 1; */
    if (message.transactionRisk !== 0)
      writer.tag(1, WireType.Bit32).float(message.transactionRisk);
    /* google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.StolenInstrumentVerdict stolen_instrument_verdict = 2; */
    if (message.stolenInstrumentVerdict)
      FraudPreventionAssessment_StolenInstrumentVerdict.internalBinaryWrite(
        message.stolenInstrumentVerdict,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.CardTestingVerdict card_testing_verdict = 3; */
    if (message.cardTestingVerdict)
      FraudPreventionAssessment_CardTestingVerdict.internalBinaryWrite(
        message.cardTestingVerdict,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.BehavioralTrustVerdict behavioral_trust_verdict = 4; */
    if (message.behavioralTrustVerdict)
      FraudPreventionAssessment_BehavioralTrustVerdict.internalBinaryWrite(
        message.behavioralTrustVerdict,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment
 */
export const FraudPreventionAssessment = new FraudPreventionAssessment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FraudPreventionAssessment_StolenInstrumentVerdict$Type extends MessageType<FraudPreventionAssessment_StolenInstrumentVerdict> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.StolenInstrumentVerdict',
      [{no: 1, name: 'risk', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/}],
    );
  }
  create(
    value?: PartialMessage<FraudPreventionAssessment_StolenInstrumentVerdict>,
  ): FraudPreventionAssessment_StolenInstrumentVerdict {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.risk = 0;
    if (value !== undefined)
      reflectionMergePartial<FraudPreventionAssessment_StolenInstrumentVerdict>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FraudPreventionAssessment_StolenInstrumentVerdict,
  ): FraudPreventionAssessment_StolenInstrumentVerdict {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* float risk */ 1:
          message.risk = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FraudPreventionAssessment_StolenInstrumentVerdict,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* float risk = 1; */
    if (message.risk !== 0) writer.tag(1, WireType.Bit32).float(message.risk);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.StolenInstrumentVerdict
 */
export const FraudPreventionAssessment_StolenInstrumentVerdict =
  new FraudPreventionAssessment_StolenInstrumentVerdict$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FraudPreventionAssessment_CardTestingVerdict$Type extends MessageType<FraudPreventionAssessment_CardTestingVerdict> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.CardTestingVerdict',
      [{no: 1, name: 'risk', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/}],
    );
  }
  create(
    value?: PartialMessage<FraudPreventionAssessment_CardTestingVerdict>,
  ): FraudPreventionAssessment_CardTestingVerdict {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.risk = 0;
    if (value !== undefined)
      reflectionMergePartial<FraudPreventionAssessment_CardTestingVerdict>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FraudPreventionAssessment_CardTestingVerdict,
  ): FraudPreventionAssessment_CardTestingVerdict {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* float risk */ 1:
          message.risk = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FraudPreventionAssessment_CardTestingVerdict,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* float risk = 1; */
    if (message.risk !== 0) writer.tag(1, WireType.Bit32).float(message.risk);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.CardTestingVerdict
 */
export const FraudPreventionAssessment_CardTestingVerdict =
  new FraudPreventionAssessment_CardTestingVerdict$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FraudPreventionAssessment_BehavioralTrustVerdict$Type extends MessageType<FraudPreventionAssessment_BehavioralTrustVerdict> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.BehavioralTrustVerdict',
      [{no: 1, name: 'trust', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/}],
    );
  }
  create(
    value?: PartialMessage<FraudPreventionAssessment_BehavioralTrustVerdict>,
  ): FraudPreventionAssessment_BehavioralTrustVerdict {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.trust = 0;
    if (value !== undefined)
      reflectionMergePartial<FraudPreventionAssessment_BehavioralTrustVerdict>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FraudPreventionAssessment_BehavioralTrustVerdict,
  ): FraudPreventionAssessment_BehavioralTrustVerdict {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* float trust */ 1:
          message.trust = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FraudPreventionAssessment_BehavioralTrustVerdict,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* float trust = 1; */
    if (message.trust !== 0) writer.tag(1, WireType.Bit32).float(message.trust);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FraudPreventionAssessment.BehavioralTrustVerdict
 */
export const FraudPreventionAssessment_BehavioralTrustVerdict =
  new FraudPreventionAssessment_BehavioralTrustVerdict$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FraudSignals$Type extends MessageType<FraudSignals> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.FraudSignals', [
      {
        no: 1,
        name: 'user_signals',
        kind: 'message',
        T: () => FraudSignals_UserSignals,
      },
      {
        no: 2,
        name: 'card_signals',
        kind: 'message',
        T: () => FraudSignals_CardSignals,
      },
    ]);
  }
  create(value?: PartialMessage<FraudSignals>): FraudSignals {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<FraudSignals>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FraudSignals,
  ): FraudSignals {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.cloud.recaptchaenterprise.v1.FraudSignals.UserSignals user_signals */ 1:
          message.userSignals = FraudSignals_UserSignals.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.userSignals,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals card_signals */ 2:
          message.cardSignals = FraudSignals_CardSignals.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.cardSignals,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FraudSignals,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.cloud.recaptchaenterprise.v1.FraudSignals.UserSignals user_signals = 1; */
    if (message.userSignals)
      FraudSignals_UserSignals.internalBinaryWrite(
        message.userSignals,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals card_signals = 2; */
    if (message.cardSignals)
      FraudSignals_CardSignals.internalBinaryWrite(
        message.cardSignals,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FraudSignals
 */
export const FraudSignals = new FraudSignals$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FraudSignals_UserSignals$Type extends MessageType<FraudSignals_UserSignals> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.FraudSignals.UserSignals', [
      {
        no: 1,
        name: 'active_days_lower_bound',
        kind: 'scalar',
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 2,
        name: 'synthetic_risk',
        kind: 'scalar',
        T: 2 /*ScalarType.FLOAT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<FraudSignals_UserSignals>,
  ): FraudSignals_UserSignals {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.activeDaysLowerBound = 0;
    message.syntheticRisk = 0;
    if (value !== undefined)
      reflectionMergePartial<FraudSignals_UserSignals>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FraudSignals_UserSignals,
  ): FraudSignals_UserSignals {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 active_days_lower_bound */ 1:
          message.activeDaysLowerBound = reader.int32();
          break;
        case /* float synthetic_risk */ 2:
          message.syntheticRisk = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FraudSignals_UserSignals,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 active_days_lower_bound = 1; */
    if (message.activeDaysLowerBound !== 0)
      writer.tag(1, WireType.Varint).int32(message.activeDaysLowerBound);
    /* float synthetic_risk = 2; */
    if (message.syntheticRisk !== 0)
      writer.tag(2, WireType.Bit32).float(message.syntheticRisk);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FraudSignals.UserSignals
 */
export const FraudSignals_UserSignals = new FraudSignals_UserSignals$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FraudSignals_CardSignals$Type extends MessageType<FraudSignals_CardSignals> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals', [
      {
        no: 1,
        name: 'card_labels',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => [
          'google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals.CardLabel',
          FraudSignals_CardSignals_CardLabel,
        ],
      },
    ]);
  }
  create(
    value?: PartialMessage<FraudSignals_CardSignals>,
  ): FraudSignals_CardSignals {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.cardLabels = [];
    if (value !== undefined)
      reflectionMergePartial<FraudSignals_CardSignals>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FraudSignals_CardSignals,
  ): FraudSignals_CardSignals {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals.CardLabel card_labels */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.cardLabels.push(reader.int32());
          else message.cardLabels.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FraudSignals_CardSignals,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals.CardLabel card_labels = 1; */
    if (message.cardLabels.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.cardLabels.length; i++)
        writer.int32(message.cardLabels[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FraudSignals.CardSignals
 */
export const FraudSignals_CardSignals = new FraudSignals_CardSignals$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SmsTollFraudVerdict$Type extends MessageType<SmsTollFraudVerdict> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict', [
      {no: 1, name: 'risk', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/},
      {
        no: 2,
        name: 'reasons',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => [
          'google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict.SmsTollFraudReason',
          SmsTollFraudVerdict_SmsTollFraudReason,
        ],
      },
    ]);
  }
  create(value?: PartialMessage<SmsTollFraudVerdict>): SmsTollFraudVerdict {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.risk = 0;
    message.reasons = [];
    if (value !== undefined)
      reflectionMergePartial<SmsTollFraudVerdict>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SmsTollFraudVerdict,
  ): SmsTollFraudVerdict {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* float risk */ 1:
          message.risk = reader.float();
          break;
        case /* repeated google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict.SmsTollFraudReason reasons */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.reasons.push(reader.int32());
          else message.reasons.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SmsTollFraudVerdict,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* float risk = 1; */
    if (message.risk !== 0) writer.tag(1, WireType.Bit32).float(message.risk);
    /* repeated google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict.SmsTollFraudReason reasons = 2; */
    if (message.reasons.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.reasons.length; i++)
        writer.int32(message.reasons[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict
 */
export const SmsTollFraudVerdict = new SmsTollFraudVerdict$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PhoneFraudAssessment$Type extends MessageType<PhoneFraudAssessment> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.PhoneFraudAssessment', [
      {
        no: 1,
        name: 'sms_toll_fraud_verdict',
        kind: 'message',
        T: () => SmsTollFraudVerdict,
      },
    ]);
  }
  create(value?: PartialMessage<PhoneFraudAssessment>): PhoneFraudAssessment {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<PhoneFraudAssessment>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PhoneFraudAssessment,
  ): PhoneFraudAssessment {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict sms_toll_fraud_verdict */ 1:
          message.smsTollFraudVerdict = SmsTollFraudVerdict.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.smsTollFraudVerdict,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PhoneFraudAssessment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.cloud.recaptchaenterprise.v1.SmsTollFraudVerdict sms_toll_fraud_verdict = 1; */
    if (message.smsTollFraudVerdict)
      SmsTollFraudVerdict.internalBinaryWrite(
        message.smsTollFraudVerdict,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.PhoneFraudAssessment
 */
export const PhoneFraudAssessment = new PhoneFraudAssessment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountDefenderAssessment$Type extends MessageType<AccountDefenderAssessment> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment', [
      {
        no: 1,
        name: 'labels',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => [
          'google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment.AccountDefenderLabel',
          AccountDefenderAssessment_AccountDefenderLabel,
        ],
      },
    ]);
  }
  create(
    value?: PartialMessage<AccountDefenderAssessment>,
  ): AccountDefenderAssessment {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.labels = [];
    if (value !== undefined)
      reflectionMergePartial<AccountDefenderAssessment>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AccountDefenderAssessment,
  ): AccountDefenderAssessment {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment.AccountDefenderLabel labels */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.labels.push(reader.int32());
          else message.labels.push(reader.int32());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AccountDefenderAssessment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment.AccountDefenderLabel labels = 1; */
    if (message.labels.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.labels.length; i++)
        writer.int32(message.labels[i]);
      writer.join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.AccountDefenderAssessment
 */
export const AccountDefenderAssessment = new AccountDefenderAssessment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateKeyRequest$Type extends MessageType<CreateKeyRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.CreateKeyRequest', [
      {no: 1, name: 'parent', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'key', kind: 'message', T: () => Key},
    ]);
  }
  create(value?: PartialMessage<CreateKeyRequest>): CreateKeyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.parent = '';
    if (value !== undefined)
      reflectionMergePartial<CreateKeyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CreateKeyRequest,
  ): CreateKeyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string parent */ 1:
          message.parent = reader.string();
          break;
        case /* google.cloud.recaptchaenterprise.v1.Key key */ 2:
          message.key = Key.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.key,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CreateKeyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string parent = 1; */
    if (message.parent !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.parent);
    /* google.cloud.recaptchaenterprise.v1.Key key = 2; */
    if (message.key)
      Key.internalBinaryWrite(
        message.key,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.CreateKeyRequest
 */
export const CreateKeyRequest = new CreateKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListKeysRequest$Type extends MessageType<ListKeysRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.ListKeysRequest', [
      {no: 1, name: 'parent', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'page_size', kind: 'scalar', T: 5 /*ScalarType.INT32*/},
      {no: 3, name: 'page_token', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(value?: PartialMessage<ListKeysRequest>): ListKeysRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.parent = '';
    message.pageSize = 0;
    message.pageToken = '';
    if (value !== undefined)
      reflectionMergePartial<ListKeysRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListKeysRequest,
  ): ListKeysRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string parent */ 1:
          message.parent = reader.string();
          break;
        case /* int32 page_size */ 2:
          message.pageSize = reader.int32();
          break;
        case /* string page_token */ 3:
          message.pageToken = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListKeysRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string parent = 1; */
    if (message.parent !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.parent);
    /* int32 page_size = 2; */
    if (message.pageSize !== 0)
      writer.tag(2, WireType.Varint).int32(message.pageSize);
    /* string page_token = 3; */
    if (message.pageToken !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.pageToken);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ListKeysRequest
 */
export const ListKeysRequest = new ListKeysRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListKeysResponse$Type extends MessageType<ListKeysResponse> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.ListKeysResponse', [
      {
        no: 1,
        name: 'keys',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Key,
      },
      {
        no: 2,
        name: 'next_page_token',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<ListKeysResponse>): ListKeysResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.keys = [];
    message.nextPageToken = '';
    if (value !== undefined)
      reflectionMergePartial<ListKeysResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListKeysResponse,
  ): ListKeysResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated google.cloud.recaptchaenterprise.v1.Key keys */ 1:
          message.keys.push(
            Key.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* string next_page_token */ 2:
          message.nextPageToken = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListKeysResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated google.cloud.recaptchaenterprise.v1.Key keys = 1; */
    for (let i = 0; i < message.keys.length; i++)
      Key.internalBinaryWrite(
        message.keys[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string next_page_token = 2; */
    if (message.nextPageToken !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ListKeysResponse
 */
export const ListKeysResponse = new ListKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveLegacySecretKeyRequest$Type extends MessageType<RetrieveLegacySecretKeyRequest> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyRequest',
      [{no: 1, name: 'key', kind: 'scalar', T: 9 /*ScalarType.STRING*/}],
    );
  }
  create(
    value?: PartialMessage<RetrieveLegacySecretKeyRequest>,
  ): RetrieveLegacySecretKeyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = '';
    if (value !== undefined)
      reflectionMergePartial<RetrieveLegacySecretKeyRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RetrieveLegacySecretKeyRequest,
  ): RetrieveLegacySecretKeyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RetrieveLegacySecretKeyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.key);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyRequest
 */
export const RetrieveLegacySecretKeyRequest =
  new RetrieveLegacySecretKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyRequest$Type extends MessageType<GetKeyRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.GetKeyRequest', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(value?: PartialMessage<GetKeyRequest>): GetKeyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    if (value !== undefined)
      reflectionMergePartial<GetKeyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetKeyRequest,
  ): GetKeyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetKeyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.GetKeyRequest
 */
export const GetKeyRequest = new GetKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateKeyRequest$Type extends MessageType<UpdateKeyRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.UpdateKeyRequest', [
      {no: 1, name: 'key', kind: 'message', T: () => Key},
      {no: 2, name: 'update_mask', kind: 'message', T: () => FieldMask},
    ]);
  }
  create(value?: PartialMessage<UpdateKeyRequest>): UpdateKeyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<UpdateKeyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UpdateKeyRequest,
  ): UpdateKeyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.cloud.recaptchaenterprise.v1.Key key */ 1:
          message.key = Key.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.key,
          );
          break;
        case /* google.protobuf.FieldMask update_mask */ 2:
          message.updateMask = FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.updateMask,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UpdateKeyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.cloud.recaptchaenterprise.v1.Key key = 1; */
    if (message.key)
      Key.internalBinaryWrite(
        message.key,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.protobuf.FieldMask update_mask = 2; */
    if (message.updateMask)
      FieldMask.internalBinaryWrite(
        message.updateMask,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.UpdateKeyRequest
 */
export const UpdateKeyRequest = new UpdateKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteKeyRequest$Type extends MessageType<DeleteKeyRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.DeleteKeyRequest', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(value?: PartialMessage<DeleteKeyRequest>): DeleteKeyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    if (value !== undefined)
      reflectionMergePartial<DeleteKeyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteKeyRequest,
  ): DeleteKeyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeleteKeyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.DeleteKeyRequest
 */
export const DeleteKeyRequest = new DeleteKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateFirewallPolicyRequest$Type extends MessageType<CreateFirewallPolicyRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.CreateFirewallPolicyRequest', [
      {no: 1, name: 'parent', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 2,
        name: 'firewall_policy',
        kind: 'message',
        T: () => FirewallPolicy,
      },
    ]);
  }
  create(
    value?: PartialMessage<CreateFirewallPolicyRequest>,
  ): CreateFirewallPolicyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.parent = '';
    if (value !== undefined)
      reflectionMergePartial<CreateFirewallPolicyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CreateFirewallPolicyRequest,
  ): CreateFirewallPolicyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string parent */ 1:
          message.parent = reader.string();
          break;
        case /* google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policy */ 2:
          message.firewallPolicy = FirewallPolicy.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.firewallPolicy,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CreateFirewallPolicyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string parent = 1; */
    if (message.parent !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.parent);
    /* google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policy = 2; */
    if (message.firewallPolicy)
      FirewallPolicy.internalBinaryWrite(
        message.firewallPolicy,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.CreateFirewallPolicyRequest
 */
export const CreateFirewallPolicyRequest =
  new CreateFirewallPolicyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFirewallPoliciesRequest$Type extends MessageType<ListFirewallPoliciesRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesRequest', [
      {no: 1, name: 'parent', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'page_size', kind: 'scalar', T: 5 /*ScalarType.INT32*/},
      {no: 3, name: 'page_token', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(
    value?: PartialMessage<ListFirewallPoliciesRequest>,
  ): ListFirewallPoliciesRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.parent = '';
    message.pageSize = 0;
    message.pageToken = '';
    if (value !== undefined)
      reflectionMergePartial<ListFirewallPoliciesRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListFirewallPoliciesRequest,
  ): ListFirewallPoliciesRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string parent */ 1:
          message.parent = reader.string();
          break;
        case /* int32 page_size */ 2:
          message.pageSize = reader.int32();
          break;
        case /* string page_token */ 3:
          message.pageToken = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListFirewallPoliciesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string parent = 1; */
    if (message.parent !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.parent);
    /* int32 page_size = 2; */
    if (message.pageSize !== 0)
      writer.tag(2, WireType.Varint).int32(message.pageSize);
    /* string page_token = 3; */
    if (message.pageToken !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.pageToken);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesRequest
 */
export const ListFirewallPoliciesRequest =
  new ListFirewallPoliciesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFirewallPoliciesResponse$Type extends MessageType<ListFirewallPoliciesResponse> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesResponse', [
      {
        no: 1,
        name: 'firewall_policies',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => FirewallPolicy,
      },
      {
        no: 2,
        name: 'next_page_token',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<ListFirewallPoliciesResponse>,
  ): ListFirewallPoliciesResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.firewallPolicies = [];
    message.nextPageToken = '';
    if (value !== undefined)
      reflectionMergePartial<ListFirewallPoliciesResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListFirewallPoliciesResponse,
  ): ListFirewallPoliciesResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policies */ 1:
          message.firewallPolicies.push(
            FirewallPolicy.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* string next_page_token */ 2:
          message.nextPageToken = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListFirewallPoliciesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policies = 1; */
    for (let i = 0; i < message.firewallPolicies.length; i++)
      FirewallPolicy.internalBinaryWrite(
        message.firewallPolicies[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string next_page_token = 2; */
    if (message.nextPageToken !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ListFirewallPoliciesResponse
 */
export const ListFirewallPoliciesResponse =
  new ListFirewallPoliciesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFirewallPolicyRequest$Type extends MessageType<GetFirewallPolicyRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.GetFirewallPolicyRequest', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(
    value?: PartialMessage<GetFirewallPolicyRequest>,
  ): GetFirewallPolicyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    if (value !== undefined)
      reflectionMergePartial<GetFirewallPolicyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetFirewallPolicyRequest,
  ): GetFirewallPolicyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetFirewallPolicyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.GetFirewallPolicyRequest
 */
export const GetFirewallPolicyRequest = new GetFirewallPolicyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateFirewallPolicyRequest$Type extends MessageType<UpdateFirewallPolicyRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.UpdateFirewallPolicyRequest', [
      {
        no: 1,
        name: 'firewall_policy',
        kind: 'message',
        T: () => FirewallPolicy,
      },
      {no: 2, name: 'update_mask', kind: 'message', T: () => FieldMask},
    ]);
  }
  create(
    value?: PartialMessage<UpdateFirewallPolicyRequest>,
  ): UpdateFirewallPolicyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<UpdateFirewallPolicyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UpdateFirewallPolicyRequest,
  ): UpdateFirewallPolicyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policy */ 1:
          message.firewallPolicy = FirewallPolicy.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.firewallPolicy,
          );
          break;
        case /* google.protobuf.FieldMask update_mask */ 2:
          message.updateMask = FieldMask.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.updateMask,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UpdateFirewallPolicyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policy = 1; */
    if (message.firewallPolicy)
      FirewallPolicy.internalBinaryWrite(
        message.firewallPolicy,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.protobuf.FieldMask update_mask = 2; */
    if (message.updateMask)
      FieldMask.internalBinaryWrite(
        message.updateMask,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.UpdateFirewallPolicyRequest
 */
export const UpdateFirewallPolicyRequest =
  new UpdateFirewallPolicyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteFirewallPolicyRequest$Type extends MessageType<DeleteFirewallPolicyRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.DeleteFirewallPolicyRequest', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(
    value?: PartialMessage<DeleteFirewallPolicyRequest>,
  ): DeleteFirewallPolicyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    if (value !== undefined)
      reflectionMergePartial<DeleteFirewallPolicyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteFirewallPolicyRequest,
  ): DeleteFirewallPolicyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeleteFirewallPolicyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.DeleteFirewallPolicyRequest
 */
export const DeleteFirewallPolicyRequest =
  new DeleteFirewallPolicyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReorderFirewallPoliciesRequest$Type extends MessageType<ReorderFirewallPoliciesRequest> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesRequest',
      [
        {no: 1, name: 'parent', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
        {
          no: 2,
          name: 'names',
          kind: 'scalar',
          repeat: 2 /*RepeatType.UNPACKED*/,
          T: 9 /*ScalarType.STRING*/,
        },
      ],
    );
  }
  create(
    value?: PartialMessage<ReorderFirewallPoliciesRequest>,
  ): ReorderFirewallPoliciesRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.parent = '';
    message.names = [];
    if (value !== undefined)
      reflectionMergePartial<ReorderFirewallPoliciesRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ReorderFirewallPoliciesRequest,
  ): ReorderFirewallPoliciesRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string parent */ 1:
          message.parent = reader.string();
          break;
        case /* repeated string names */ 2:
          message.names.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ReorderFirewallPoliciesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string parent = 1; */
    if (message.parent !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.parent);
    /* repeated string names = 2; */
    for (let i = 0; i < message.names.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.names[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesRequest
 */
export const ReorderFirewallPoliciesRequest =
  new ReorderFirewallPoliciesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReorderFirewallPoliciesResponse$Type extends MessageType<ReorderFirewallPoliciesResponse> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesResponse',
      [],
    );
  }
  create(
    value?: PartialMessage<ReorderFirewallPoliciesResponse>,
  ): ReorderFirewallPoliciesResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<ReorderFirewallPoliciesResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ReorderFirewallPoliciesResponse,
  ): ReorderFirewallPoliciesResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: ReorderFirewallPoliciesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ReorderFirewallPoliciesResponse
 */
export const ReorderFirewallPoliciesResponse =
  new ReorderFirewallPoliciesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MigrateKeyRequest$Type extends MessageType<MigrateKeyRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.MigrateKeyRequest', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 2,
        name: 'skip_billing_check',
        kind: 'scalar',
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<MigrateKeyRequest>): MigrateKeyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    message.skipBillingCheck = false;
    if (value !== undefined)
      reflectionMergePartial<MigrateKeyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MigrateKeyRequest,
  ): MigrateKeyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* bool skip_billing_check */ 2:
          message.skipBillingCheck = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MigrateKeyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* bool skip_billing_check = 2; */
    if (message.skipBillingCheck !== false)
      writer.tag(2, WireType.Varint).bool(message.skipBillingCheck);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.MigrateKeyRequest
 */
export const MigrateKeyRequest = new MigrateKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMetricsRequest$Type extends MessageType<GetMetricsRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.GetMetricsRequest', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(value?: PartialMessage<GetMetricsRequest>): GetMetricsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    if (value !== undefined)
      reflectionMergePartial<GetMetricsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetMetricsRequest,
  ): GetMetricsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetMetricsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.GetMetricsRequest
 */
export const GetMetricsRequest = new GetMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metrics$Type extends MessageType<Metrics> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.Metrics', [
      {no: 4, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 1, name: 'start_time', kind: 'message', T: () => Timestamp},
      {
        no: 2,
        name: 'score_metrics',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ScoreMetrics,
      },
      {
        no: 3,
        name: 'challenge_metrics',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ChallengeMetrics,
      },
    ]);
  }
  create(value?: PartialMessage<Metrics>): Metrics {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    message.scoreMetrics = [];
    message.challengeMetrics = [];
    if (value !== undefined)
      reflectionMergePartial<Metrics>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Metrics,
  ): Metrics {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 4:
          message.name = reader.string();
          break;
        case /* google.protobuf.Timestamp start_time */ 1:
          message.startTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.startTime,
          );
          break;
        case /* repeated google.cloud.recaptchaenterprise.v1.ScoreMetrics score_metrics */ 2:
          message.scoreMetrics.push(
            ScoreMetrics.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated google.cloud.recaptchaenterprise.v1.ChallengeMetrics challenge_metrics */ 3:
          message.challengeMetrics.push(
            ChallengeMetrics.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Metrics,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 4; */
    if (message.name !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.name);
    /* google.protobuf.Timestamp start_time = 1; */
    if (message.startTime)
      Timestamp.internalBinaryWrite(
        message.startTime,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated google.cloud.recaptchaenterprise.v1.ScoreMetrics score_metrics = 2; */
    for (let i = 0; i < message.scoreMetrics.length; i++)
      ScoreMetrics.internalBinaryWrite(
        message.scoreMetrics[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated google.cloud.recaptchaenterprise.v1.ChallengeMetrics challenge_metrics = 3; */
    for (let i = 0; i < message.challengeMetrics.length; i++)
      ChallengeMetrics.internalBinaryWrite(
        message.challengeMetrics[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.Metrics
 */
export const Metrics = new Metrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveLegacySecretKeyResponse$Type extends MessageType<RetrieveLegacySecretKeyResponse> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyResponse',
      [
        {
          no: 1,
          name: 'legacy_secret_key',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
      ],
    );
  }
  create(
    value?: PartialMessage<RetrieveLegacySecretKeyResponse>,
  ): RetrieveLegacySecretKeyResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.legacySecretKey = '';
    if (value !== undefined)
      reflectionMergePartial<RetrieveLegacySecretKeyResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RetrieveLegacySecretKeyResponse,
  ): RetrieveLegacySecretKeyResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string legacy_secret_key */ 1:
          message.legacySecretKey = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RetrieveLegacySecretKeyResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string legacy_secret_key = 1; */
    if (message.legacySecretKey !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.legacySecretKey);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.RetrieveLegacySecretKeyResponse
 */
export const RetrieveLegacySecretKeyResponse =
  new RetrieveLegacySecretKeyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Key$Type extends MessageType<Key> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.Key', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'display_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 3,
        name: 'web_settings',
        kind: 'message',
        oneof: 'platformSettings',
        T: () => WebKeySettings,
      },
      {
        no: 4,
        name: 'android_settings',
        kind: 'message',
        oneof: 'platformSettings',
        T: () => AndroidKeySettings,
      },
      {
        no: 5,
        name: 'ios_settings',
        kind: 'message',
        oneof: 'platformSettings',
        T: () => IOSKeySettings,
      },
      {
        no: 11,
        name: 'express_settings',
        kind: 'message',
        oneof: 'platformSettings',
        T: () => ExpressKeySettings,
      },
      {
        no: 6,
        name: 'labels',
        kind: 'map',
        K: 9 /*ScalarType.STRING*/,
        V: {kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      },
      {no: 7, name: 'create_time', kind: 'message', T: () => Timestamp},
      {
        no: 9,
        name: 'testing_options',
        kind: 'message',
        T: () => TestingOptions,
      },
      {no: 10, name: 'waf_settings', kind: 'message', T: () => WafSettings},
    ]);
  }
  create(value?: PartialMessage<Key>): Key {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    message.displayName = '';
    message.platformSettings = {oneofKind: undefined};
    message.labels = {};
    if (value !== undefined) reflectionMergePartial<Key>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Key,
  ): Key {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* string display_name */ 2:
          message.displayName = reader.string();
          break;
        case /* google.cloud.recaptchaenterprise.v1.WebKeySettings web_settings */ 3:
          message.platformSettings = {
            oneofKind: 'webSettings',
            webSettings: WebKeySettings.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.platformSettings as any).webSettings,
            ),
          };
          break;
        case /* google.cloud.recaptchaenterprise.v1.AndroidKeySettings android_settings */ 4:
          message.platformSettings = {
            oneofKind: 'androidSettings',
            androidSettings: AndroidKeySettings.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.platformSettings as any).androidSettings,
            ),
          };
          break;
        case /* google.cloud.recaptchaenterprise.v1.IOSKeySettings ios_settings */ 5:
          message.platformSettings = {
            oneofKind: 'iosSettings',
            iosSettings: IOSKeySettings.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.platformSettings as any).iosSettings,
            ),
          };
          break;
        case /* google.cloud.recaptchaenterprise.v1.ExpressKeySettings express_settings */ 11:
          message.platformSettings = {
            oneofKind: 'expressSettings',
            expressSettings: ExpressKeySettings.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.platformSettings as any).expressSettings,
            ),
          };
          break;
        case /* map<string, string> labels */ 6:
          this.binaryReadMap6(message.labels, reader, options);
          break;
        case /* google.protobuf.Timestamp create_time */ 7:
          message.createTime = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.createTime,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.TestingOptions testing_options */ 9:
          message.testingOptions = TestingOptions.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.testingOptions,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.WafSettings waf_settings */ 10:
          message.wafSettings = WafSettings.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.wafSettings,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap6(
    map: Key['labels'],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof Key['labels'] | undefined,
      val: Key['labels'][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = reader.string();
          break;
        default:
          throw new globalThis.Error(
            'unknown map entry field for field google.cloud.recaptchaenterprise.v1.Key.labels',
          );
      }
    }
    map[key ?? ''] = val ?? '';
  }
  internalBinaryWrite(
    message: Key,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* string display_name = 2; */
    if (message.displayName !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.displayName);
    /* google.cloud.recaptchaenterprise.v1.WebKeySettings web_settings = 3; */
    if (message.platformSettings.oneofKind === 'webSettings')
      WebKeySettings.internalBinaryWrite(
        message.platformSettings.webSettings,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.AndroidKeySettings android_settings = 4; */
    if (message.platformSettings.oneofKind === 'androidSettings')
      AndroidKeySettings.internalBinaryWrite(
        message.platformSettings.androidSettings,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.IOSKeySettings ios_settings = 5; */
    if (message.platformSettings.oneofKind === 'iosSettings')
      IOSKeySettings.internalBinaryWrite(
        message.platformSettings.iosSettings,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.ExpressKeySettings express_settings = 11; */
    if (message.platformSettings.oneofKind === 'expressSettings')
      ExpressKeySettings.internalBinaryWrite(
        message.platformSettings.expressSettings,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* map<string, string> labels = 6; */
    for (let k of globalThis.Object.keys(message.labels))
      writer
        .tag(6, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k)
        .tag(2, WireType.LengthDelimited)
        .string(message.labels[k])
        .join();
    /* google.protobuf.Timestamp create_time = 7; */
    if (message.createTime)
      Timestamp.internalBinaryWrite(
        message.createTime,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.TestingOptions testing_options = 9; */
    if (message.testingOptions)
      TestingOptions.internalBinaryWrite(
        message.testingOptions,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.WafSettings waf_settings = 10; */
    if (message.wafSettings)
      WafSettings.internalBinaryWrite(
        message.wafSettings,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.Key
 */
export const Key = new Key$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestingOptions$Type extends MessageType<TestingOptions> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.TestingOptions', [
      {no: 1, name: 'testing_score', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/},
      {
        no: 2,
        name: 'testing_challenge',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.TestingOptions.TestingChallenge',
          TestingOptions_TestingChallenge,
        ],
      },
    ]);
  }
  create(value?: PartialMessage<TestingOptions>): TestingOptions {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.testingScore = 0;
    message.testingChallenge = 0;
    if (value !== undefined)
      reflectionMergePartial<TestingOptions>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TestingOptions,
  ): TestingOptions {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* float testing_score */ 1:
          message.testingScore = reader.float();
          break;
        case /* google.cloud.recaptchaenterprise.v1.TestingOptions.TestingChallenge testing_challenge */ 2:
          message.testingChallenge = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: TestingOptions,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* float testing_score = 1; */
    if (message.testingScore !== 0)
      writer.tag(1, WireType.Bit32).float(message.testingScore);
    /* google.cloud.recaptchaenterprise.v1.TestingOptions.TestingChallenge testing_challenge = 2; */
    if (message.testingChallenge !== 0)
      writer.tag(2, WireType.Varint).int32(message.testingChallenge);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.TestingOptions
 */
export const TestingOptions = new TestingOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebKeySettings$Type extends MessageType<WebKeySettings> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.WebKeySettings', [
      {
        no: 3,
        name: 'allow_all_domains',
        kind: 'scalar',
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 1,
        name: 'allowed_domains',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: 'allow_amp_traffic',
        kind: 'scalar',
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 4,
        name: 'integration_type',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.WebKeySettings.IntegrationType',
          WebKeySettings_IntegrationType,
        ],
      },
      {
        no: 5,
        name: 'challenge_security_preference',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.WebKeySettings.ChallengeSecurityPreference',
          WebKeySettings_ChallengeSecurityPreference,
        ],
      },
    ]);
  }
  create(value?: PartialMessage<WebKeySettings>): WebKeySettings {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.allowAllDomains = false;
    message.allowedDomains = [];
    message.allowAmpTraffic = false;
    message.integrationType = 0;
    message.challengeSecurityPreference = 0;
    if (value !== undefined)
      reflectionMergePartial<WebKeySettings>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: WebKeySettings,
  ): WebKeySettings {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool allow_all_domains */ 3:
          message.allowAllDomains = reader.bool();
          break;
        case /* repeated string allowed_domains */ 1:
          message.allowedDomains.push(reader.string());
          break;
        case /* bool allow_amp_traffic */ 2:
          message.allowAmpTraffic = reader.bool();
          break;
        case /* google.cloud.recaptchaenterprise.v1.WebKeySettings.IntegrationType integration_type */ 4:
          message.integrationType = reader.int32();
          break;
        case /* google.cloud.recaptchaenterprise.v1.WebKeySettings.ChallengeSecurityPreference challenge_security_preference */ 5:
          message.challengeSecurityPreference = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: WebKeySettings,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool allow_all_domains = 3; */
    if (message.allowAllDomains !== false)
      writer.tag(3, WireType.Varint).bool(message.allowAllDomains);
    /* repeated string allowed_domains = 1; */
    for (let i = 0; i < message.allowedDomains.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.allowedDomains[i]);
    /* bool allow_amp_traffic = 2; */
    if (message.allowAmpTraffic !== false)
      writer.tag(2, WireType.Varint).bool(message.allowAmpTraffic);
    /* google.cloud.recaptchaenterprise.v1.WebKeySettings.IntegrationType integration_type = 4; */
    if (message.integrationType !== 0)
      writer.tag(4, WireType.Varint).int32(message.integrationType);
    /* google.cloud.recaptchaenterprise.v1.WebKeySettings.ChallengeSecurityPreference challenge_security_preference = 5; */
    if (message.challengeSecurityPreference !== 0)
      writer.tag(5, WireType.Varint).int32(message.challengeSecurityPreference);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.WebKeySettings
 */
export const WebKeySettings = new WebKeySettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AndroidKeySettings$Type extends MessageType<AndroidKeySettings> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.AndroidKeySettings', [
      {
        no: 2,
        name: 'allow_all_package_names',
        kind: 'scalar',
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 1,
        name: 'allowed_package_names',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: 'support_non_google_app_store_distribution',
        kind: 'scalar',
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<AndroidKeySettings>): AndroidKeySettings {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.allowAllPackageNames = false;
    message.allowedPackageNames = [];
    message.supportNonGoogleAppStoreDistribution = false;
    if (value !== undefined)
      reflectionMergePartial<AndroidKeySettings>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AndroidKeySettings,
  ): AndroidKeySettings {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool allow_all_package_names */ 2:
          message.allowAllPackageNames = reader.bool();
          break;
        case /* repeated string allowed_package_names */ 1:
          message.allowedPackageNames.push(reader.string());
          break;
        case /* bool support_non_google_app_store_distribution */ 3:
          message.supportNonGoogleAppStoreDistribution = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AndroidKeySettings,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool allow_all_package_names = 2; */
    if (message.allowAllPackageNames !== false)
      writer.tag(2, WireType.Varint).bool(message.allowAllPackageNames);
    /* repeated string allowed_package_names = 1; */
    for (let i = 0; i < message.allowedPackageNames.length; i++)
      writer
        .tag(1, WireType.LengthDelimited)
        .string(message.allowedPackageNames[i]);
    /* bool support_non_google_app_store_distribution = 3; */
    if (message.supportNonGoogleAppStoreDistribution !== false)
      writer
        .tag(3, WireType.Varint)
        .bool(message.supportNonGoogleAppStoreDistribution);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.AndroidKeySettings
 */
export const AndroidKeySettings = new AndroidKeySettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IOSKeySettings$Type extends MessageType<IOSKeySettings> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.IOSKeySettings', [
      {
        no: 2,
        name: 'allow_all_bundle_ids',
        kind: 'scalar',
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 1,
        name: 'allowed_bundle_ids',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: 'apple_developer_id',
        kind: 'message',
        T: () => AppleDeveloperId,
      },
    ]);
  }
  create(value?: PartialMessage<IOSKeySettings>): IOSKeySettings {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.allowAllBundleIds = false;
    message.allowedBundleIds = [];
    if (value !== undefined)
      reflectionMergePartial<IOSKeySettings>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: IOSKeySettings,
  ): IOSKeySettings {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool allow_all_bundle_ids */ 2:
          message.allowAllBundleIds = reader.bool();
          break;
        case /* repeated string allowed_bundle_ids */ 1:
          message.allowedBundleIds.push(reader.string());
          break;
        case /* google.cloud.recaptchaenterprise.v1.AppleDeveloperId apple_developer_id */ 3:
          message.appleDeveloperId = AppleDeveloperId.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.appleDeveloperId,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: IOSKeySettings,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool allow_all_bundle_ids = 2; */
    if (message.allowAllBundleIds !== false)
      writer.tag(2, WireType.Varint).bool(message.allowAllBundleIds);
    /* repeated string allowed_bundle_ids = 1; */
    for (let i = 0; i < message.allowedBundleIds.length; i++)
      writer
        .tag(1, WireType.LengthDelimited)
        .string(message.allowedBundleIds[i]);
    /* google.cloud.recaptchaenterprise.v1.AppleDeveloperId apple_developer_id = 3; */
    if (message.appleDeveloperId)
      AppleDeveloperId.internalBinaryWrite(
        message.appleDeveloperId,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.IOSKeySettings
 */
export const IOSKeySettings = new IOSKeySettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpressKeySettings$Type extends MessageType<ExpressKeySettings> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.ExpressKeySettings', []);
  }
  create(value?: PartialMessage<ExpressKeySettings>): ExpressKeySettings {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<ExpressKeySettings>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ExpressKeySettings,
  ): ExpressKeySettings {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: ExpressKeySettings,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ExpressKeySettings
 */
export const ExpressKeySettings = new ExpressKeySettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppleDeveloperId$Type extends MessageType<AppleDeveloperId> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.AppleDeveloperId', [
      {no: 1, name: 'private_key', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'key_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 3, name: 'team_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(value?: PartialMessage<AppleDeveloperId>): AppleDeveloperId {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.privateKey = '';
    message.keyId = '';
    message.teamId = '';
    if (value !== undefined)
      reflectionMergePartial<AppleDeveloperId>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AppleDeveloperId,
  ): AppleDeveloperId {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string private_key */ 1:
          message.privateKey = reader.string();
          break;
        case /* string key_id */ 2:
          message.keyId = reader.string();
          break;
        case /* string team_id */ 3:
          message.teamId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AppleDeveloperId,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string private_key = 1; */
    if (message.privateKey !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.privateKey);
    /* string key_id = 2; */
    if (message.keyId !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.keyId);
    /* string team_id = 3; */
    if (message.teamId !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.teamId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.AppleDeveloperId
 */
export const AppleDeveloperId = new AppleDeveloperId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScoreDistribution$Type extends MessageType<ScoreDistribution> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.ScoreDistribution', [
      {
        no: 1,
        name: 'score_buckets',
        kind: 'map',
        K: 5 /*ScalarType.INT32*/,
        V: {
          kind: 'scalar',
          T: 3 /*ScalarType.INT64*/,
          L: 0 /*LongType.BIGINT*/,
        },
      },
    ]);
  }
  create(value?: PartialMessage<ScoreDistribution>): ScoreDistribution {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.scoreBuckets = {};
    if (value !== undefined)
      reflectionMergePartial<ScoreDistribution>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScoreDistribution,
  ): ScoreDistribution {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<int32, int64> score_buckets */ 1:
          this.binaryReadMap1(message.scoreBuckets, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: ScoreDistribution['scoreBuckets'],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof ScoreDistribution['scoreBuckets'] | undefined,
      val: ScoreDistribution['scoreBuckets'][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.int32();
          break;
        case 2:
          val = reader.int64().toBigInt();
          break;
        default:
          throw new globalThis.Error(
            'unknown map entry field for field google.cloud.recaptchaenterprise.v1.ScoreDistribution.score_buckets',
          );
      }
    }
    map[key ?? 0] = val ?? 0n;
  }
  internalBinaryWrite(
    message: ScoreDistribution,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* map<int32, int64> score_buckets = 1; */
    for (let k of globalThis.Object.keys(message.scoreBuckets))
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.Varint)
        .int32(parseInt(k))
        .tag(2, WireType.Varint)
        .int64(message.scoreBuckets[k as any])
        .join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ScoreDistribution
 */
export const ScoreDistribution = new ScoreDistribution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScoreMetrics$Type extends MessageType<ScoreMetrics> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.ScoreMetrics', [
      {
        no: 1,
        name: 'overall_metrics',
        kind: 'message',
        T: () => ScoreDistribution,
      },
      {
        no: 2,
        name: 'action_metrics',
        kind: 'map',
        K: 9 /*ScalarType.STRING*/,
        V: {kind: 'message', T: () => ScoreDistribution},
      },
    ]);
  }
  create(value?: PartialMessage<ScoreMetrics>): ScoreMetrics {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.actionMetrics = {};
    if (value !== undefined)
      reflectionMergePartial<ScoreMetrics>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScoreMetrics,
  ): ScoreMetrics {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.cloud.recaptchaenterprise.v1.ScoreDistribution overall_metrics */ 1:
          message.overallMetrics = ScoreDistribution.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.overallMetrics,
          );
          break;
        case /* map<string, google.cloud.recaptchaenterprise.v1.ScoreDistribution> action_metrics */ 2:
          this.binaryReadMap2(message.actionMetrics, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap2(
    map: ScoreMetrics['actionMetrics'],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof ScoreMetrics['actionMetrics'] | undefined,
      val: ScoreMetrics['actionMetrics'][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = ScoreDistribution.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
          );
          break;
        default:
          throw new globalThis.Error(
            'unknown map entry field for field google.cloud.recaptchaenterprise.v1.ScoreMetrics.action_metrics',
          );
      }
    }
    map[key ?? ''] = val ?? ScoreDistribution.create();
  }
  internalBinaryWrite(
    message: ScoreMetrics,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.cloud.recaptchaenterprise.v1.ScoreDistribution overall_metrics = 1; */
    if (message.overallMetrics)
      ScoreDistribution.internalBinaryWrite(
        message.overallMetrics,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* map<string, google.cloud.recaptchaenterprise.v1.ScoreDistribution> action_metrics = 2; */
    for (let k of globalThis.Object.keys(message.actionMetrics)) {
      writer
        .tag(2, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      ScoreDistribution.internalBinaryWrite(
        message.actionMetrics[k],
        writer,
        options,
      );
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ScoreMetrics
 */
export const ScoreMetrics = new ScoreMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChallengeMetrics$Type extends MessageType<ChallengeMetrics> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.ChallengeMetrics', [
      {
        no: 1,
        name: 'pageload_count',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 2,
        name: 'nocaptcha_count',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: 'failed_count',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 4,
        name: 'passed_count',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(value?: PartialMessage<ChallengeMetrics>): ChallengeMetrics {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.pageloadCount = 0n;
    message.nocaptchaCount = 0n;
    message.failedCount = 0n;
    message.passedCount = 0n;
    if (value !== undefined)
      reflectionMergePartial<ChallengeMetrics>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ChallengeMetrics,
  ): ChallengeMetrics {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 pageload_count */ 1:
          message.pageloadCount = reader.int64().toBigInt();
          break;
        case /* int64 nocaptcha_count */ 2:
          message.nocaptchaCount = reader.int64().toBigInt();
          break;
        case /* int64 failed_count */ 3:
          message.failedCount = reader.int64().toBigInt();
          break;
        case /* int64 passed_count */ 4:
          message.passedCount = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ChallengeMetrics,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 pageload_count = 1; */
    if (message.pageloadCount !== 0n)
      writer.tag(1, WireType.Varint).int64(message.pageloadCount);
    /* int64 nocaptcha_count = 2; */
    if (message.nocaptchaCount !== 0n)
      writer.tag(2, WireType.Varint).int64(message.nocaptchaCount);
    /* int64 failed_count = 3; */
    if (message.failedCount !== 0n)
      writer.tag(3, WireType.Varint).int64(message.failedCount);
    /* int64 passed_count = 4; */
    if (message.passedCount !== 0n)
      writer.tag(4, WireType.Varint).int64(message.passedCount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ChallengeMetrics
 */
export const ChallengeMetrics = new ChallengeMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirewallPolicyAssessment$Type extends MessageType<FirewallPolicyAssessment> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.FirewallPolicyAssessment', [
      {no: 5, name: 'error', kind: 'message', T: () => Status},
      {
        no: 8,
        name: 'firewall_policy',
        kind: 'message',
        T: () => FirewallPolicy,
      },
    ]);
  }
  create(
    value?: PartialMessage<FirewallPolicyAssessment>,
  ): FirewallPolicyAssessment {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<FirewallPolicyAssessment>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FirewallPolicyAssessment,
  ): FirewallPolicyAssessment {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.rpc.Status error */ 5:
          message.error = Status.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.error,
          );
          break;
        case /* google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policy */ 8:
          message.firewallPolicy = FirewallPolicy.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.firewallPolicy,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FirewallPolicyAssessment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.rpc.Status error = 5; */
    if (message.error)
      Status.internalBinaryWrite(
        message.error,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FirewallPolicy firewall_policy = 8; */
    if (message.firewallPolicy)
      FirewallPolicy.internalBinaryWrite(
        message.firewallPolicy,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FirewallPolicyAssessment
 */
export const FirewallPolicyAssessment = new FirewallPolicyAssessment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirewallAction$Type extends MessageType<FirewallAction> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.FirewallAction', [
      {
        no: 1,
        name: 'allow',
        kind: 'message',
        oneof: 'firewallActionOneof',
        T: () => FirewallAction_AllowAction,
      },
      {
        no: 2,
        name: 'block',
        kind: 'message',
        oneof: 'firewallActionOneof',
        T: () => FirewallAction_BlockAction,
      },
      {
        no: 6,
        name: 'include_recaptcha_script',
        kind: 'message',
        oneof: 'firewallActionOneof',
        T: () => FirewallAction_IncludeRecaptchaScriptAction,
      },
      {
        no: 5,
        name: 'redirect',
        kind: 'message',
        oneof: 'firewallActionOneof',
        T: () => FirewallAction_RedirectAction,
      },
      {
        no: 3,
        name: 'substitute',
        kind: 'message',
        oneof: 'firewallActionOneof',
        T: () => FirewallAction_SubstituteAction,
      },
      {
        no: 4,
        name: 'set_header',
        kind: 'message',
        oneof: 'firewallActionOneof',
        T: () => FirewallAction_SetHeaderAction,
      },
    ]);
  }
  create(value?: PartialMessage<FirewallAction>): FirewallAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.firewallActionOneof = {oneofKind: undefined};
    if (value !== undefined)
      reflectionMergePartial<FirewallAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FirewallAction,
  ): FirewallAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.cloud.recaptchaenterprise.v1.FirewallAction.AllowAction allow */ 1:
          message.firewallActionOneof = {
            oneofKind: 'allow',
            allow: FirewallAction_AllowAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.firewallActionOneof as any).allow,
            ),
          };
          break;
        case /* google.cloud.recaptchaenterprise.v1.FirewallAction.BlockAction block */ 2:
          message.firewallActionOneof = {
            oneofKind: 'block',
            block: FirewallAction_BlockAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.firewallActionOneof as any).block,
            ),
          };
          break;
        case /* google.cloud.recaptchaenterprise.v1.FirewallAction.IncludeRecaptchaScriptAction include_recaptcha_script */ 6:
          message.firewallActionOneof = {
            oneofKind: 'includeRecaptchaScript',
            includeRecaptchaScript:
              FirewallAction_IncludeRecaptchaScriptAction.internalBinaryRead(
                reader,
                reader.uint32(),
                options,
                (message.firewallActionOneof as any).includeRecaptchaScript,
              ),
          };
          break;
        case /* google.cloud.recaptchaenterprise.v1.FirewallAction.RedirectAction redirect */ 5:
          message.firewallActionOneof = {
            oneofKind: 'redirect',
            redirect: FirewallAction_RedirectAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.firewallActionOneof as any).redirect,
            ),
          };
          break;
        case /* google.cloud.recaptchaenterprise.v1.FirewallAction.SubstituteAction substitute */ 3:
          message.firewallActionOneof = {
            oneofKind: 'substitute',
            substitute: FirewallAction_SubstituteAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.firewallActionOneof as any).substitute,
            ),
          };
          break;
        case /* google.cloud.recaptchaenterprise.v1.FirewallAction.SetHeaderAction set_header */ 4:
          message.firewallActionOneof = {
            oneofKind: 'setHeader',
            setHeader: FirewallAction_SetHeaderAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.firewallActionOneof as any).setHeader,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FirewallAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.cloud.recaptchaenterprise.v1.FirewallAction.AllowAction allow = 1; */
    if (message.firewallActionOneof.oneofKind === 'allow')
      FirewallAction_AllowAction.internalBinaryWrite(
        message.firewallActionOneof.allow,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FirewallAction.BlockAction block = 2; */
    if (message.firewallActionOneof.oneofKind === 'block')
      FirewallAction_BlockAction.internalBinaryWrite(
        message.firewallActionOneof.block,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FirewallAction.IncludeRecaptchaScriptAction include_recaptcha_script = 6; */
    if (message.firewallActionOneof.oneofKind === 'includeRecaptchaScript')
      FirewallAction_IncludeRecaptchaScriptAction.internalBinaryWrite(
        message.firewallActionOneof.includeRecaptchaScript,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FirewallAction.RedirectAction redirect = 5; */
    if (message.firewallActionOneof.oneofKind === 'redirect')
      FirewallAction_RedirectAction.internalBinaryWrite(
        message.firewallActionOneof.redirect,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FirewallAction.SubstituteAction substitute = 3; */
    if (message.firewallActionOneof.oneofKind === 'substitute')
      FirewallAction_SubstituteAction.internalBinaryWrite(
        message.firewallActionOneof.substitute,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.cloud.recaptchaenterprise.v1.FirewallAction.SetHeaderAction set_header = 4; */
    if (message.firewallActionOneof.oneofKind === 'setHeader')
      FirewallAction_SetHeaderAction.internalBinaryWrite(
        message.firewallActionOneof.setHeader,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction
 */
export const FirewallAction = new FirewallAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirewallAction_AllowAction$Type extends MessageType<FirewallAction_AllowAction> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.FirewallAction.AllowAction', []);
  }
  create(
    value?: PartialMessage<FirewallAction_AllowAction>,
  ): FirewallAction_AllowAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<FirewallAction_AllowAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FirewallAction_AllowAction,
  ): FirewallAction_AllowAction {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: FirewallAction_AllowAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.AllowAction
 */
export const FirewallAction_AllowAction = new FirewallAction_AllowAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirewallAction_BlockAction$Type extends MessageType<FirewallAction_BlockAction> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.FirewallAction.BlockAction', []);
  }
  create(
    value?: PartialMessage<FirewallAction_BlockAction>,
  ): FirewallAction_BlockAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<FirewallAction_BlockAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FirewallAction_BlockAction,
  ): FirewallAction_BlockAction {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: FirewallAction_BlockAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.BlockAction
 */
export const FirewallAction_BlockAction = new FirewallAction_BlockAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirewallAction_IncludeRecaptchaScriptAction$Type extends MessageType<FirewallAction_IncludeRecaptchaScriptAction> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.FirewallAction.IncludeRecaptchaScriptAction',
      [],
    );
  }
  create(
    value?: PartialMessage<FirewallAction_IncludeRecaptchaScriptAction>,
  ): FirewallAction_IncludeRecaptchaScriptAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<FirewallAction_IncludeRecaptchaScriptAction>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FirewallAction_IncludeRecaptchaScriptAction,
  ): FirewallAction_IncludeRecaptchaScriptAction {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: FirewallAction_IncludeRecaptchaScriptAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.IncludeRecaptchaScriptAction
 */
export const FirewallAction_IncludeRecaptchaScriptAction =
  new FirewallAction_IncludeRecaptchaScriptAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirewallAction_RedirectAction$Type extends MessageType<FirewallAction_RedirectAction> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.FirewallAction.RedirectAction',
      [],
    );
  }
  create(
    value?: PartialMessage<FirewallAction_RedirectAction>,
  ): FirewallAction_RedirectAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<FirewallAction_RedirectAction>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FirewallAction_RedirectAction,
  ): FirewallAction_RedirectAction {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: FirewallAction_RedirectAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.RedirectAction
 */
export const FirewallAction_RedirectAction =
  new FirewallAction_RedirectAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirewallAction_SubstituteAction$Type extends MessageType<FirewallAction_SubstituteAction> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.FirewallAction.SubstituteAction',
      [{no: 1, name: 'path', kind: 'scalar', T: 9 /*ScalarType.STRING*/}],
    );
  }
  create(
    value?: PartialMessage<FirewallAction_SubstituteAction>,
  ): FirewallAction_SubstituteAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.path = '';
    if (value !== undefined)
      reflectionMergePartial<FirewallAction_SubstituteAction>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FirewallAction_SubstituteAction,
  ): FirewallAction_SubstituteAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string path */ 1:
          message.path = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FirewallAction_SubstituteAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string path = 1; */
    if (message.path !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.path);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.SubstituteAction
 */
export const FirewallAction_SubstituteAction =
  new FirewallAction_SubstituteAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirewallAction_SetHeaderAction$Type extends MessageType<FirewallAction_SetHeaderAction> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.FirewallAction.SetHeaderAction',
      [
        {no: 1, name: 'key', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
        {no: 2, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      ],
    );
  }
  create(
    value?: PartialMessage<FirewallAction_SetHeaderAction>,
  ): FirewallAction_SetHeaderAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = '';
    message.value = '';
    if (value !== undefined)
      reflectionMergePartial<FirewallAction_SetHeaderAction>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FirewallAction_SetHeaderAction,
  ): FirewallAction_SetHeaderAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* string value */ 2:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FirewallAction_SetHeaderAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* string value = 2; */
    if (message.value !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FirewallAction.SetHeaderAction
 */
export const FirewallAction_SetHeaderAction =
  new FirewallAction_SetHeaderAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirewallPolicy$Type extends MessageType<FirewallPolicy> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.FirewallPolicy', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'description', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 4, name: 'path', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 5, name: 'condition', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 6,
        name: 'actions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => FirewallAction,
      },
    ]);
  }
  create(value?: PartialMessage<FirewallPolicy>): FirewallPolicy {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    message.description = '';
    message.path = '';
    message.condition = '';
    message.actions = [];
    if (value !== undefined)
      reflectionMergePartial<FirewallPolicy>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FirewallPolicy,
  ): FirewallPolicy {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* string description */ 2:
          message.description = reader.string();
          break;
        case /* string path */ 4:
          message.path = reader.string();
          break;
        case /* string condition */ 5:
          message.condition = reader.string();
          break;
        case /* repeated google.cloud.recaptchaenterprise.v1.FirewallAction actions */ 6:
          message.actions.push(
            FirewallAction.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: FirewallPolicy,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* string description = 2; */
    if (message.description !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    /* string path = 4; */
    if (message.path !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.path);
    /* string condition = 5; */
    if (message.condition !== '')
      writer.tag(5, WireType.LengthDelimited).string(message.condition);
    /* repeated google.cloud.recaptchaenterprise.v1.FirewallAction actions = 6; */
    for (let i = 0; i < message.actions.length; i++)
      FirewallAction.internalBinaryWrite(
        message.actions[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.FirewallPolicy
 */
export const FirewallPolicy = new FirewallPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRelatedAccountGroupMembershipsRequest$Type extends MessageType<ListRelatedAccountGroupMembershipsRequest> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsRequest',
      [
        {no: 1, name: 'parent', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
        {no: 2, name: 'page_size', kind: 'scalar', T: 5 /*ScalarType.INT32*/},
        {no: 3, name: 'page_token', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      ],
    );
  }
  create(
    value?: PartialMessage<ListRelatedAccountGroupMembershipsRequest>,
  ): ListRelatedAccountGroupMembershipsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.parent = '';
    message.pageSize = 0;
    message.pageToken = '';
    if (value !== undefined)
      reflectionMergePartial<ListRelatedAccountGroupMembershipsRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListRelatedAccountGroupMembershipsRequest,
  ): ListRelatedAccountGroupMembershipsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string parent */ 1:
          message.parent = reader.string();
          break;
        case /* int32 page_size */ 2:
          message.pageSize = reader.int32();
          break;
        case /* string page_token */ 3:
          message.pageToken = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListRelatedAccountGroupMembershipsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string parent = 1; */
    if (message.parent !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.parent);
    /* int32 page_size = 2; */
    if (message.pageSize !== 0)
      writer.tag(2, WireType.Varint).int32(message.pageSize);
    /* string page_token = 3; */
    if (message.pageToken !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.pageToken);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsRequest
 */
export const ListRelatedAccountGroupMembershipsRequest =
  new ListRelatedAccountGroupMembershipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRelatedAccountGroupMembershipsResponse$Type extends MessageType<ListRelatedAccountGroupMembershipsResponse> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsResponse',
      [
        {
          no: 1,
          name: 'related_account_group_memberships',
          kind: 'message',
          repeat: 1 /*RepeatType.PACKED*/,
          T: () => RelatedAccountGroupMembership,
        },
        {
          no: 2,
          name: 'next_page_token',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
      ],
    );
  }
  create(
    value?: PartialMessage<ListRelatedAccountGroupMembershipsResponse>,
  ): ListRelatedAccountGroupMembershipsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.relatedAccountGroupMemberships = [];
    message.nextPageToken = '';
    if (value !== undefined)
      reflectionMergePartial<ListRelatedAccountGroupMembershipsResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListRelatedAccountGroupMembershipsResponse,
  ): ListRelatedAccountGroupMembershipsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership related_account_group_memberships */ 1:
          message.relatedAccountGroupMemberships.push(
            RelatedAccountGroupMembership.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* string next_page_token */ 2:
          message.nextPageToken = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListRelatedAccountGroupMembershipsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership related_account_group_memberships = 1; */
    for (let i = 0; i < message.relatedAccountGroupMemberships.length; i++)
      RelatedAccountGroupMembership.internalBinaryWrite(
        message.relatedAccountGroupMemberships[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string next_page_token = 2; */
    if (message.nextPageToken !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupMembershipsResponse
 */
export const ListRelatedAccountGroupMembershipsResponse =
  new ListRelatedAccountGroupMembershipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRelatedAccountGroupsRequest$Type extends MessageType<ListRelatedAccountGroupsRequest> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsRequest',
      [
        {no: 1, name: 'parent', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
        {no: 2, name: 'page_size', kind: 'scalar', T: 5 /*ScalarType.INT32*/},
        {no: 3, name: 'page_token', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      ],
    );
  }
  create(
    value?: PartialMessage<ListRelatedAccountGroupsRequest>,
  ): ListRelatedAccountGroupsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.parent = '';
    message.pageSize = 0;
    message.pageToken = '';
    if (value !== undefined)
      reflectionMergePartial<ListRelatedAccountGroupsRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListRelatedAccountGroupsRequest,
  ): ListRelatedAccountGroupsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string parent */ 1:
          message.parent = reader.string();
          break;
        case /* int32 page_size */ 2:
          message.pageSize = reader.int32();
          break;
        case /* string page_token */ 3:
          message.pageToken = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListRelatedAccountGroupsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string parent = 1; */
    if (message.parent !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.parent);
    /* int32 page_size = 2; */
    if (message.pageSize !== 0)
      writer.tag(2, WireType.Varint).int32(message.pageSize);
    /* string page_token = 3; */
    if (message.pageToken !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.pageToken);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsRequest
 */
export const ListRelatedAccountGroupsRequest =
  new ListRelatedAccountGroupsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRelatedAccountGroupsResponse$Type extends MessageType<ListRelatedAccountGroupsResponse> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsResponse',
      [
        {
          no: 1,
          name: 'related_account_groups',
          kind: 'message',
          repeat: 1 /*RepeatType.PACKED*/,
          T: () => RelatedAccountGroup,
        },
        {
          no: 2,
          name: 'next_page_token',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
      ],
    );
  }
  create(
    value?: PartialMessage<ListRelatedAccountGroupsResponse>,
  ): ListRelatedAccountGroupsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.relatedAccountGroups = [];
    message.nextPageToken = '';
    if (value !== undefined)
      reflectionMergePartial<ListRelatedAccountGroupsResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListRelatedAccountGroupsResponse,
  ): ListRelatedAccountGroupsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated google.cloud.recaptchaenterprise.v1.RelatedAccountGroup related_account_groups */ 1:
          message.relatedAccountGroups.push(
            RelatedAccountGroup.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* string next_page_token */ 2:
          message.nextPageToken = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListRelatedAccountGroupsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated google.cloud.recaptchaenterprise.v1.RelatedAccountGroup related_account_groups = 1; */
    for (let i = 0; i < message.relatedAccountGroups.length; i++)
      RelatedAccountGroup.internalBinaryWrite(
        message.relatedAccountGroups[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string next_page_token = 2; */
    if (message.nextPageToken !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.ListRelatedAccountGroupsResponse
 */
export const ListRelatedAccountGroupsResponse =
  new ListRelatedAccountGroupsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchRelatedAccountGroupMembershipsRequest$Type extends MessageType<SearchRelatedAccountGroupMembershipsRequest> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsRequest',
      [
        {no: 1, name: 'project', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
        {no: 5, name: 'account_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
        {
          no: 2,
          name: 'hashed_account_id',
          kind: 'scalar',
          T: 12 /*ScalarType.BYTES*/,
        },
        {no: 3, name: 'page_size', kind: 'scalar', T: 5 /*ScalarType.INT32*/},
        {no: 4, name: 'page_token', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      ],
    );
  }
  create(
    value?: PartialMessage<SearchRelatedAccountGroupMembershipsRequest>,
  ): SearchRelatedAccountGroupMembershipsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.project = '';
    message.accountId = '';
    message.hashedAccountId = new Uint8Array(0);
    message.pageSize = 0;
    message.pageToken = '';
    if (value !== undefined)
      reflectionMergePartial<SearchRelatedAccountGroupMembershipsRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SearchRelatedAccountGroupMembershipsRequest,
  ): SearchRelatedAccountGroupMembershipsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string project */ 1:
          message.project = reader.string();
          break;
        case /* string account_id */ 5:
          message.accountId = reader.string();
          break;
        case /* bytes hashed_account_id */ 2:
          message.hashedAccountId = reader.bytes();
          break;
        case /* int32 page_size */ 3:
          message.pageSize = reader.int32();
          break;
        case /* string page_token */ 4:
          message.pageToken = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SearchRelatedAccountGroupMembershipsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string project = 1; */
    if (message.project !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.project);
    /* string account_id = 5; */
    if (message.accountId !== '')
      writer.tag(5, WireType.LengthDelimited).string(message.accountId);
    /* bytes hashed_account_id = 2; */
    if (message.hashedAccountId.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.hashedAccountId);
    /* int32 page_size = 3; */
    if (message.pageSize !== 0)
      writer.tag(3, WireType.Varint).int32(message.pageSize);
    /* string page_token = 4; */
    if (message.pageToken !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.pageToken);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsRequest
 */
export const SearchRelatedAccountGroupMembershipsRequest =
  new SearchRelatedAccountGroupMembershipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchRelatedAccountGroupMembershipsResponse$Type extends MessageType<SearchRelatedAccountGroupMembershipsResponse> {
  constructor() {
    super(
      'google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsResponse',
      [
        {
          no: 1,
          name: 'related_account_group_memberships',
          kind: 'message',
          repeat: 1 /*RepeatType.PACKED*/,
          T: () => RelatedAccountGroupMembership,
        },
        {
          no: 2,
          name: 'next_page_token',
          kind: 'scalar',
          T: 9 /*ScalarType.STRING*/,
        },
      ],
    );
  }
  create(
    value?: PartialMessage<SearchRelatedAccountGroupMembershipsResponse>,
  ): SearchRelatedAccountGroupMembershipsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.relatedAccountGroupMemberships = [];
    message.nextPageToken = '';
    if (value !== undefined)
      reflectionMergePartial<SearchRelatedAccountGroupMembershipsResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SearchRelatedAccountGroupMembershipsResponse,
  ): SearchRelatedAccountGroupMembershipsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership related_account_group_memberships */ 1:
          message.relatedAccountGroupMemberships.push(
            RelatedAccountGroupMembership.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* string next_page_token */ 2:
          message.nextPageToken = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SearchRelatedAccountGroupMembershipsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership related_account_group_memberships = 1; */
    for (let i = 0; i < message.relatedAccountGroupMemberships.length; i++)
      RelatedAccountGroupMembership.internalBinaryWrite(
        message.relatedAccountGroupMemberships[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string next_page_token = 2; */
    if (message.nextPageToken !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.SearchRelatedAccountGroupMembershipsResponse
 */
export const SearchRelatedAccountGroupMembershipsResponse =
  new SearchRelatedAccountGroupMembershipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddIpOverrideRequest$Type extends MessageType<AddIpOverrideRequest> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.AddIpOverrideRequest', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 2,
        name: 'ip_override_data',
        kind: 'message',
        T: () => IpOverrideData,
      },
    ]);
  }
  create(value?: PartialMessage<AddIpOverrideRequest>): AddIpOverrideRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    if (value !== undefined)
      reflectionMergePartial<AddIpOverrideRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddIpOverrideRequest,
  ): AddIpOverrideRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* google.cloud.recaptchaenterprise.v1.IpOverrideData ip_override_data */ 2:
          message.ipOverrideData = IpOverrideData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.ipOverrideData,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AddIpOverrideRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* google.cloud.recaptchaenterprise.v1.IpOverrideData ip_override_data = 2; */
    if (message.ipOverrideData)
      IpOverrideData.internalBinaryWrite(
        message.ipOverrideData,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.AddIpOverrideRequest
 */
export const AddIpOverrideRequest = new AddIpOverrideRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddIpOverrideResponse$Type extends MessageType<AddIpOverrideResponse> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.AddIpOverrideResponse', []);
  }
  create(value?: PartialMessage<AddIpOverrideResponse>): AddIpOverrideResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<AddIpOverrideResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddIpOverrideResponse,
  ): AddIpOverrideResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: AddIpOverrideResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.AddIpOverrideResponse
 */
export const AddIpOverrideResponse = new AddIpOverrideResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelatedAccountGroupMembership$Type extends MessageType<RelatedAccountGroupMembership> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 4, name: 'account_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 2,
        name: 'hashed_account_id',
        kind: 'scalar',
        T: 12 /*ScalarType.BYTES*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<RelatedAccountGroupMembership>,
  ): RelatedAccountGroupMembership {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    message.accountId = '';
    message.hashedAccountId = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<RelatedAccountGroupMembership>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RelatedAccountGroupMembership,
  ): RelatedAccountGroupMembership {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* string account_id */ 4:
          message.accountId = reader.string();
          break;
        case /* bytes hashed_account_id = 2 [deprecated = true];*/ 2:
          message.hashedAccountId = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RelatedAccountGroupMembership,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* string account_id = 4; */
    if (message.accountId !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.accountId);
    /* bytes hashed_account_id = 2 [deprecated = true]; */
    if (message.hashedAccountId.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.hashedAccountId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.RelatedAccountGroupMembership
 */
export const RelatedAccountGroupMembership =
  new RelatedAccountGroupMembership$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelatedAccountGroup$Type extends MessageType<RelatedAccountGroup> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.RelatedAccountGroup', [
      {no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(value?: PartialMessage<RelatedAccountGroup>): RelatedAccountGroup {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.name = '';
    if (value !== undefined)
      reflectionMergePartial<RelatedAccountGroup>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RelatedAccountGroup,
  ): RelatedAccountGroup {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RelatedAccountGroup,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.RelatedAccountGroup
 */
export const RelatedAccountGroup = new RelatedAccountGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WafSettings$Type extends MessageType<WafSettings> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.WafSettings', [
      {
        no: 1,
        name: 'waf_service',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.WafSettings.WafService',
          WafSettings_WafService,
        ],
      },
      {
        no: 2,
        name: 'waf_feature',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.WafSettings.WafFeature',
          WafSettings_WafFeature,
        ],
      },
    ]);
  }
  create(value?: PartialMessage<WafSettings>): WafSettings {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.wafService = 0;
    message.wafFeature = 0;
    if (value !== undefined)
      reflectionMergePartial<WafSettings>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: WafSettings,
  ): WafSettings {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.cloud.recaptchaenterprise.v1.WafSettings.WafService waf_service */ 1:
          message.wafService = reader.int32();
          break;
        case /* google.cloud.recaptchaenterprise.v1.WafSettings.WafFeature waf_feature */ 2:
          message.wafFeature = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: WafSettings,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.cloud.recaptchaenterprise.v1.WafSettings.WafService waf_service = 1; */
    if (message.wafService !== 0)
      writer.tag(1, WireType.Varint).int32(message.wafService);
    /* google.cloud.recaptchaenterprise.v1.WafSettings.WafFeature waf_feature = 2; */
    if (message.wafFeature !== 0)
      writer.tag(2, WireType.Varint).int32(message.wafFeature);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.WafSettings
 */
export const WafSettings = new WafSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssessmentEnvironment$Type extends MessageType<AssessmentEnvironment> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.AssessmentEnvironment', [
      {no: 1, name: 'client', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {no: 2, name: 'version', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
    ]);
  }
  create(value?: PartialMessage<AssessmentEnvironment>): AssessmentEnvironment {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.client = '';
    message.version = '';
    if (value !== undefined)
      reflectionMergePartial<AssessmentEnvironment>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AssessmentEnvironment,
  ): AssessmentEnvironment {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string client */ 1:
          message.client = reader.string();
          break;
        case /* string version */ 2:
          message.version = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AssessmentEnvironment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string client = 1; */
    if (message.client !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.client);
    /* string version = 2; */
    if (message.version !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.version);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.AssessmentEnvironment
 */
export const AssessmentEnvironment = new AssessmentEnvironment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IpOverrideData$Type extends MessageType<IpOverrideData> {
  constructor() {
    super('google.cloud.recaptchaenterprise.v1.IpOverrideData', [
      {no: 1, name: 'ip', kind: 'scalar', T: 9 /*ScalarType.STRING*/},
      {
        no: 3,
        name: 'override_type',
        kind: 'enum',
        T: () => [
          'google.cloud.recaptchaenterprise.v1.IpOverrideData.OverrideType',
          IpOverrideData_OverrideType,
        ],
      },
    ]);
  }
  create(value?: PartialMessage<IpOverrideData>): IpOverrideData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.ip = '';
    message.overrideType = 0;
    if (value !== undefined)
      reflectionMergePartial<IpOverrideData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: IpOverrideData,
  ): IpOverrideData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ip */ 1:
          message.ip = reader.string();
          break;
        case /* google.cloud.recaptchaenterprise.v1.IpOverrideData.OverrideType override_type */ 3:
          message.overrideType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: IpOverrideData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string ip = 1; */
    if (message.ip !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.ip);
    /* google.cloud.recaptchaenterprise.v1.IpOverrideData.OverrideType override_type = 3; */
    if (message.overrideType !== 0)
      writer.tag(3, WireType.Varint).int32(message.overrideType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message google.cloud.recaptchaenterprise.v1.IpOverrideData
 */
export const IpOverrideData = new IpOverrideData$Type();
